{
    "metadata": {
        "type": "repo",
        "path": "stream_gpt/knowledge_tree/tree/construct_tree.py"
    },
    "text": "import stream_gpt.knowledge_tree.tree.tree_class as knowledge_tree\nimport stream_gpt.utils.inference as call_models\nimport stream_gpt.constants.prompts as prompts\n\nclass Basic_Construct_Tree_From_Chunked_Document:\n    '''\n        This class creates a hierarchal knowledge tree representing the given text (Already broken into chunks), guided by the given prompt.\n        \n        1. Add each chunk to the tree as a leaf node\n        2. Summarize and label each chunk with keywords. Add these 'compressed chunks' to the tree as parents of the corresponding leaf nodes.\n        3. Combine nearby 'compressed chunks' into a single 'compressed chunk', and summarize and label it with keywords. Add this 'compressed chunk' \n           to the tree as a parent of the corresponding 'compressed chunks'.\n        4. Repeat step 3 until a singular root summary node is obtained.\n    '''\n    def __init__(self, chunks, text_id, prompt):\n        '''\n            Args:\n            - chunks    (list): List of text chunks\n            - text_id   (string): Unique name of the text you want to be saved in the tree\n            - prompt    (string): Describe how you want the text to be saved in the tree\n\n            Returns:\n            - tree      (Knowledge_Tree): A hierarchal knowledge tree representing the given text\n        '''\n        self.chunks = chunks\n        self.text_id = text_id\n        self.prompt = prompt\n        self.tree = knowledge_tree.Knowledge_Tree()\n        leaf_layer = [f'0_{text_id}{i}' for i in range(len(chunks) + 1)] # Creates a list of keys for the leaf nodes in the tree\n        self.tree.add_layer(leaf_layer, chunks) # Adds chunks to the tree as nodes with no connections yet\n        self.hierarchical_summarization(leaf_layer)\n        \n    def hierarchical_summarization(self, layer):\n        '''\n        Initiates a hierarchical summarization process from a layer of unconnected leaf nodes.\n        Each leaf node contains a text chunk. The function summarizes each chunk, elevating\n        these summaries to form a new parent layer. It then combines nearby nodes within this \n        layer, summarizes them, and continues this process iteratively, forming a hierarchy \n        of summarized information, until a singular root summary node is obtained.\n        \n            Args:\n            - layer         (list): Keys of the nodes in the layer\n            \n            Returns:\n            - None\n        '''\n        root_summary_done = False\n        depth = 0\n        while(not root_summary_done):\n            depth += 1\n            next_layer = self.summarize_layer(layer, depth)\n            if(len(next_layer) == 1):\n                root_summary_done = True\n                self.tree.root = next_layer[0]\n            layer = next_layer\n\n    def summarize_layer(self, layer, depth, granularity=2):\n        '''\n        Summarizes a layer of the knowledge base.\n        \n            Args:\n            - layer         (list): Keys of the nodes in the layer\n            - depth         (int): Depth of the layer being summarized\n            - granularity   (int): How many nodes to combine into a single node\n\n            Returns:\n            - new_layer    (list): Keys of the nodes in the layer just created\n        '''\n        # Loop through {granularity} nodes at a time, summarizing them, and adding the summary as a parent of those nodes\n        new_layer = []\n        index = 0\n        for i in range(0, len(layer), granularity):\n            nodes_to_process = layer[i:min(i+granularity, len(layer))]\n            text = ''\n            for node in nodes_to_process:\n                text += f\"\\n{self.tree.nodes[node]['data']}\"\n            summary = call_models.summarize(self.prompt, text)\n            self.tree.add_parent(f'{depth}_{self.text_id}{index}', children_ids=nodes_to_process, data=summary)\n            new_layer.append(f'{depth}_{self.text_id}{index}')\n        return new_layer"
}