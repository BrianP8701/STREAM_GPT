{
    "metadata": {
        "type": "repo",
        "path": "src/threads/MeasureMetrics.py"
    },
    "text": "'''\n    MeasureMetrics is responsible for providing metrics driven research on the extrusion process.\n    \n    We will measure different performance critical aspects of the system, such as:\n\n        - Speed\n        - RAM usage\n        - Classification accuracy\n        - Diameter measurement accuracy\n        \n    Each of these metrics will be measured in a separate thread. Each thread will act as an observor.\n'''\nimport src.variables.global_vars as GV\nimport src.helpers.helper_functions as helpers\nimport src.helpers.metrics as metrics\nimport src.helpers.drawing_functions as d\nimport src.helpers.preprocessing as preprocessing\nfrom src.threads.Analytics import Analytics\nimport queue\nimport cv2\nimport threading\nimport psutil\nimport os\nimport time\n\nclass MeasureMetrics:\n    def __init__(self, json_path, speed=False, ram=False, classification=False, diameter=False):\n        self.json_path = json_path\n        self.speed = speed\n        self.ram = ram\n        self.classification = classification\n        self.diameter = diameter\n        self.ram_history = [] # [time, ram_usage]\n        self.speed_history = [] # [frame_index, time_since_last_inference]\n        \n    def start(self):\n        if self.speed:\n            threading.Thread(target=self.measure_speed, args=()).start()\n        if self.ram:\n            threading.Thread(target=self.measure_ram_usage, args=()).start()\n        if self.classification:\n            threading.Thread(target=self.measure_classification, args=()).start()\n        if self.diameter:\n            threading.Thread(target=self.measure_diameter, args=()).start()\n\n    def measure_speed(self):\n        '''\n            Measure speed by measuring the time between MobileNet inferences\n        '''\n        last_frame_index = GV.measure_speed_queue.get() \n        while True:\n            try:\n                frame_index = GV.measure_speed_queue.get(timeout=5) \n            except queue.Empty:\n                if GV.tracking_done:\n                    break\n                else:\n                    continue\n            frame_difference = frame_index - last_frame_index\n            last_frame_index = frame_index\n            print(f'Frame difference: {frame_difference}')\n            self.speed_history.append([frame_index, frame_difference])\n            \n        metrics.update_json_dicts(self.json_path, {\"speed\": self.speed_history})\n    \n    def measure_ram_usage(self):\n        '''\n            Measure RAM USage\n        '''\n        while True:\n            start_time = time.time()\n            if GV.tracking_done:\n                break\n            ram_usage = self.measure_ram()\n            self.ram_history.append([start_time, ram_usage])\n            elapsed_time = time.time() - start_time\n            if elapsed_time < 5:\n                time.sleep(5 - elapsed_time)\n                \n        metrics.update_json_dicts(self.json_path, {\"ram\": self.ram_history})\n    \n    def measure_classification(self):\n        pass\n    \n    def measure_diameter(self):\n        pass\n    \n    def measure_ram(self):\n        process = psutil.Process(os.getpid())\n        ram_usage = process.memory_info().rss\n        return ram_usage"
}