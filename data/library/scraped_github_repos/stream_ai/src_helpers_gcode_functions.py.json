{
    "metadata": {
        "type": "repo",
        "path": "src/helpers/gcode_functions.py"
    },
    "text": "'''\nThis file contains functions that parse gcode files and return a list of bed locations,\nand any other gcode related functions.\n'''\nimport src.helpers.helper_functions as hf\nimport numpy as np\nimport math\nimport warnings\n'''\nInput: \n    gcode file\n    acceleration value\n    fps\n\nOutput:\n    point_list: list of locations of tip for every frame\n    angle_list: list of angles at each frame\n                --> Frame by frame\n                [a, b, c, d, e ...]\n    corner_indices: list of indices in point_list that are corners\n'''\ndef gcode_parser(gcode_path: str, acceleration: float, fps: int, time_k: float):\n\n    # List of [x, y, z, speed]\n    corners = simplify_gcode(gcode_path)\n    frame = 0\n\n    bed_predictions = []\n    angle_list = []\n    corner_indices = []\n    velocity = np.array([0.0,0.0,0.0])\n    leftover_frames = 0\n    # Loop through each corner\n    for corner_index in range(len(corners)):\n        # Skip if first or last line of gcode\n        if corner_index == 0: continue\n        if corner_index == len(corners) - 1: break\n        \n        if len(bed_predictions) != 0: corner_indices.append(len(bed_predictions)-1)\n        else: corner_indices.append(0)\n        \n        # [x, y, z]\n        location = np.array(corners[corner_index-1][0:3])\n        next_location = np.array(corners[corner_index][0:3])\n        next_next_location = np.array(corners[corner_index+1][0:3])\n        # mm/s\n        max_speed = corners[corner_index][3]\n        next_max_speed = corners[corner_index+1][3]\n        # vectors\n        displacement = next_location - location\n        next_displacement = next_next_location - next_location\n        # scalars\n        distance = hf.magnitude(displacement)\n        speed = hf.magnitude(velocity)\n        \n        final_velocity = hf.normalize(displacement) * max_speed\n        next_max_velocity = hf.normalize(next_displacement) * next_max_speed\n        final_velocity, final_speed = speed_at_end_of_this_move(final_velocity, next_max_velocity)\n        if final_speed > max_speed:\n            final_speed = max_speed\n            final_velocity = hf.normalize(displacement) * final_speed\n        \n        # In milliseconds\n        time_for_move, achieved_final_speed = how_long(abs(distance), abs(speed), abs(final_speed), abs(max_speed), acceleration)\n        time_for_move *= time_k\n        achieved_final_velocity = hf.normalize(displacement) * achieved_final_speed\n        \n        frames_for_move = int(time_for_move * fps + leftover_frames)\n            \n        leftover_frames = (time_for_move * fps + leftover_frames) - frames_for_move\n \n        if frames_for_move != 0: velocity = (displacement / frames_for_move)\n        else: velocity = 0\n        angle = math.atan2(displacement[1], displacement[0]) * 180 / math.pi\n        \n        for frame in range(frames_for_move):\n            bed_predictions.append(location + velocity * frame)\n            angle_list.append(angle)\n            \n        bed_predictions.append(next_location)\n        angle_list.append(angle)\n        \n        velocity = achieved_final_velocity\n        \n    corner_indices.append(len(bed_predictions)-1)\n    return bed_predictions, angle_list, corner_indices\n\n\n'''\nReturns list of:\n    [x, y, z, speed]\nfor each corner\n'''\ndef simplify_gcode(gcode_path):\n    corners = []\n    \n    # Open gcode file\n    with open(gcode_path, 'r') as f_gcode:\n        gcode = f_gcode.read()\n        gcode: list = gcode.split(\"\\n\")\n    \n    speed = 0\n    line, g_index = get_first_line(gcode)\n    corners.append(line)\n    position = line\n    line, g_index = get_next_line(gcode, g_index)\n    \n    while g_index != -1:\n        for i in range (0,3):\n            if line[i] == -1: line[i] = position[i]\n        \n        if line[3] == -1: line[3] = speed\n        else: \n            line[3] = line[3] / 60\n            speed = line[3]\n        \n        position = line\n        corners.append(line)\n        line, g_index = get_next_line(gcode, g_index)\n        \n    return corners\n\n# Get first line of gcode where we know x, y and z\ndef get_first_line(data: list[str]):\n    line_data = [-1.0, -1.0, -1.0, -1.0]\n    index = 0\n    \n    while(index < len(data)):\n        \n        # Break at end of file\n        if(index >= len(data)): return line_data, -1\n        \n        if(data[index][:2] == 'G1'): \n            line: list = data[index].split(\" \")\n            \n            for c in line:\n                if(c[:1] == \"X\"): line_data[0] = float(c[1:])\n                elif(c[:1] == \"Y\"): line_data[1] = float(c[1:])\n                elif(c[:1] == \"Z\"): line_data[2] = float(c[1:])\n                elif(c[:1] == \"F\"): line_data[3] = float(c[1:])\n\n            # If all values are filled, return\n            if all(i != -1 for i in line_data[:2]): return line_data, index+1\n            \n        index += 1\n        \n    # Return -1 if no more lines\n    return line_data, -1\n\n# Returns the next line of gcode starting with G1\ndef get_next_line(data: list[str], index):\n                    # x, y, z, f\n    line_data = [-1.0, -1.0, -1.0, -1.0]\n    \n    while(index < len(data)):\n        \n        # Break at end of file\n        if(index >= len(data)): return line_data, -1\n        \n        if(data[index][:2] == 'G1'): \n            line: list = data[index].split(\" \")\n            \n            for c in line:\n                if(c[:1] == \"X\"): line_data[0] = float(c[1:])\n                elif(c[:1] == \"Y\"): line_data[1] = float(c[1:])\n                elif(c[:1] == \"Z\"): line_data[2] = float(c[1:])\n                elif(c[:1] == \"F\"): line_data[3] = float(c[1:])\n\n            # If all values are filled, return\n            if all(i != -1 for i in line_data[:2]): return line_data, index+1\n            elif line_data[2] != -1: return line_data, index+1\n            \n        index += 1\n        \n    # Return -1 if no more lines\n    return line_data, -1\n\n\ndef how_long(distance: float, curr_speed: float, final_speed: float, \n                        max_speed: float, acceleration: float) -> tuple:\n    \"\"\"\n    Calculates the minimum time required to cover a given distance starting at curr_speed, \n    not exceeding max_speed, and finishing at final_speed. Returns a tuple (time, achieved_final_speed).\n    \"\"\"\n    \n    # s1: Distance covered while moving from curr_speed to max_speed (accelerating if curr_speed is less than max_speed and decelerating if curr_speed is greater than max_speed):\n    # s2: Distance covered while moving from max_speed to final_speed (accelerating if max_speed is less than final_speed and decelerating if max_speed is greater than final_speed):\n    # s3: Distance covered while moving from curr_speed to final_speed:\n    s1, t1, s2, t2, s3 = compute_travel_parameters(curr_speed, final_speed, max_speed, acceleration)\n    accelerating = final_speed > curr_speed\n    \n    if s1 > distance: # We can't reach max speed\n        if s3 > distance: # We can't reach final speed either\n            warnings.warn(\"Failed to reach the desired final speed within the given distance. Optimal Travel Time function.\")         \n            # Calculate the final speed achievable within the given distance\n            if accelerating: value_inside_sqrt = curr_speed**2 + 2*acceleration*distance\n            else: value_inside_sqrt = curr_speed**2 - 2*acceleration*distance\n            achievable_speed_change = value_inside_sqrt**0.5\n            achieved_final_speed = curr_speed + achievable_speed_change\n            time_to_achieve_speed_change = achievable_speed_change / acceleration\n            return time_to_achieve_speed_change, achieved_final_speed\n        \n        else: # We can reach final speed. We want to accelerate as much as we can, then decelerate to final speed\n            return optimal_travel_time(distance, curr_speed, final_speed, acceleration)\n        \n    else: # We can reach max speed\n        if s1 + s2 < distance: # We can reach max speed and final speed\n            time_in_between = (distance - s1 - s2) / max_speed\n            time = t1 + time_in_between + t2\n            return time, final_speed\n\n        else: # If we achieve max speed, we can't reach final speed. We want to accelerate as much as we can, then decelerate to final speed\n            return optimal_travel_time(distance, curr_speed, final_speed, acceleration)\n\n\ndef compute_travel_parameters(curr_speed: float, final_speed: float, \n                                 max_speed: float, acceleration: float) -> dict:\n    '''\n        All inputs are expected to be positive magnitudes.\n    \n        s1: Distance covered while moving from curr_speed to max_speed (accelerating if curr_speed is less than max_speed and decelerating if curr_speed is greater than max_speed):\n        s2: Distance covered while moving from max_speed to final_speed (accelerating if max_speed is less than final_speed and decelerating if max_speed is greater than final_speed):\n        s3: Distance covered while moving from curr_speed to final_speed:\n\n        For s1 and s2, the sign of the time (whether it's positive or negative) will indicate the direction of the acceleration or deceleration. If the time is positive, it means we're accelerating; if negative, we're decelerating.\n    '''\n    # s1 and time to do s1\n    s1 = (max_speed**2 - curr_speed**2) / (2 * acceleration)\n    time_s1 = abs((max_speed - curr_speed) / acceleration)\n    \n    # s2 and time to do s2\n    s2 = (max_speed**2 - final_speed**2) / (2 * acceleration)\n    time_s2 = abs((max_speed - final_speed) / acceleration)\n    \n    # s3 and time to do s3 (which is also direct_decel_distance and time to do direct_decel_distance)\n    s3 = (final_speed**2 - curr_speed**2) / (2 * acceleration)\n    \n    return s1, time_s1, s2, time_s2, s3\n\n\ndef optimal_travel_time(distance, curr_speed, final_speed, acceleration):\n     # If curr_speed equals final_speed, we split the distance in half.\n    if curr_speed == final_speed:\n        s_accel = distance / 2\n        v_intermediate = (2 * acceleration * s_accel + curr_speed**2)**0.5\n    else:\n        # Start with an initial guess\n        s_accel = distance / 2\n        s_decel = distance - s_accel\n        # Adjust by 10%, 1% and 0.1% of the total distance until we're close enough to the desired final_speed\n        # If curr_speed is less than final_speed, we accelerate for more than half the distance.\n        # If curr_speed is greater than final_speed, we accelerate for less than half the distance.\n        for i in range(30):\n            if i < 10: percent_adjustment = 0.1\n            elif i < 20: percent_adjustment = 0.01\n            else: percent_adjustment = 0.001\n            # While maintaining the correct total distance, adjust s_accel and s_decel until final_speed is achieved\n            # Compute v_intermediate after accelerating over s_accel\n            v_intermediate = (2 * acceleration * s_accel + curr_speed**2)**0.5\n            # Compute final speed after decelerating over s_decel from v_intermediate\n            under_root = v_intermediate**2 - 2 * acceleration * s_decel\n            if under_root < 0: v_final_after_decel = 0\n            else: v_final_after_decel = under_root**0.5\n            # Adjust s_accel and s_decel\n            if v_final_after_decel < final_speed:\n                # Initially we should be \n                s_accel += percent_adjustment * distance  # Some small percentage of total distance\n            else:\n                s_accel -= percent_adjustment * distance  # Some small percentage of total distance\n                if s_accel < 0: s_accel = 0\n                \n    # Now we compute times\n    t1 = (-curr_speed + v_intermediate) / acceleration\n    t2 = (v_intermediate - final_speed) / acceleration  # Since we're decelerating\n    return t1 + t2, final_speed\n\n# Calculates the final speed of the move\ndef speed_at_end_of_this_move(final_velocity: np.ndarray,  next_max_velocity: np.ndarray) -> float:\n    # Logic to tweak final velocity\n    if final_velocity[0] >= 0 and next_max_velocity[0] <= 0: final_velocity[0] = 0\n    elif abs(final_velocity[0]) > abs(next_max_velocity[0]): final_velocity[0] = next_max_velocity[0]\n    if final_velocity[1] >= 0 and next_max_velocity[1] <= 0: final_velocity[1] = 0\n    elif abs(final_velocity[1]) > abs(next_max_velocity[1]): final_velocity[1] = next_max_velocity[1]\n    if final_velocity[2] >= 0 and next_max_velocity[2] <= 0: final_velocity[2] = 0\n    elif abs(final_velocity[2]) > abs(next_max_velocity[2]): final_velocity[2] = next_max_velocity[2]\n    final_speed = hf.magnitude(final_velocity)\n    return final_velocity, final_speed"
}