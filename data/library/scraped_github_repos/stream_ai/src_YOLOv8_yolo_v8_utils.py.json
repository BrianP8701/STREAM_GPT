{
    "metadata": {
        "type": "repo",
        "path": "src/YOLOv8/yolo_v8/utils.py"
    },
    "text": "import numpy as np\nimport cv2\n\nclass_names = ['3DPrinter-Tip']\n\n# Create a list of colors for each class where each color is a tuple of 3 integer values\nrng = np.random.default_rng(3)\ncolors = rng.uniform(0, 255, size=(len(class_names), 3))\n\n\ndef nms(boxes, scores, iou_threshold):\n    # Sort by score\n    sorted_indices = np.argsort(scores)[::-1]\n\n    keep_boxes = []\n    while sorted_indices.size > 0:\n        # Pick the last box\n        box_id = sorted_indices[0]\n        keep_boxes.append(box_id)\n\n        # Compute IoU of the picked box with the rest\n        ious = compute_iou(boxes[box_id, :], boxes[sorted_indices[1:], :])\n\n        # Remove boxes with IoU over the threshold\n        keep_indices = np.where(ious < iou_threshold)[0]\n\n        # print(keep_indices.shape, sorted_indices.shape)\n        sorted_indices = sorted_indices[keep_indices + 1]\n\n    return keep_boxes\n\n\ndef compute_iou(box, boxes):\n    # Compute xmin, ymin, xmax, ymax for both boxes\n    xmin = np.maximum(box[0], boxes[:, 0])\n    ymin = np.maximum(box[1], boxes[:, 1])\n    xmax = np.minimum(box[2], boxes[:, 2])\n    ymax = np.minimum(box[3], boxes[:, 3])\n\n    # Compute intersection area\n    intersection_area = np.maximum(0, xmax - xmin) * np.maximum(0, ymax - ymin)\n\n    # Compute union area\n    box_area = (box[2] - box[0]) * (box[3] - box[1])\n    boxes_area = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])\n    union_area = box_area + boxes_area - intersection_area\n\n    # Compute IoU\n    iou = intersection_area / union_area\n\n    return iou\n\n\ndef xywh2xyxy(x):\n    # Convert bounding box (x, y, w, h) to bounding box (x1, y1, x2, y2)\n    y = np.copy(x)\n    y[..., 0] = x[..., 0] - x[..., 2] / 2\n    y[..., 1] = x[..., 1] - x[..., 3] / 2\n    y[..., 2] = x[..., 0] + x[..., 2] / 2\n    y[..., 3] = x[..., 1] + x[..., 3] / 2\n    return y\n\n\ndef draw_detections(image, boxes, scores, class_ids, mask_alpha=0.3):\n    mask_img = image.copy()\n    det_img = image.copy()\n\n    img_height, img_width = image.shape[:2]\n    size = min([img_height, img_width]) * 0.0006\n    text_thickness = int(min([img_height, img_width]) * 0.001)\n\n    # Draw bounding boxes and labels of detections\n    for box, score, class_id in zip(boxes, scores, class_ids):\n        color = colors[class_id]\n\n        x1, y1, x2, y2 = box.astype(int)\n\n        # Draw rectangle\n        cv2.rectangle(det_img, (x1, y1), (x2, y2), color, 2)\n\n        # Draw fill rectangle in mask image\n        cv2.rectangle(mask_img, (x1, y1), (x2, y2), color, -1)\n\n        label = class_names[class_id]\n        caption = f'{label} {int(score * 100)}%'\n        (tw, th), _ = cv2.getTextSize(text=caption, fontFace=cv2.FONT_HERSHEY_SIMPLEX,\n                                      fontScale=size, thickness=text_thickness)\n        th = int(th * 1.2)\n\n        cv2.rectangle(det_img, (x1, y1),\n                      (x1 + tw, y1 - th), color, -1)\n        cv2.rectangle(mask_img, (x1, y1),\n                      (x1 + tw, y1 - th), color, -1)\n        cv2.putText(det_img, caption, (x1, y1),\n                    cv2.FONT_HERSHEY_SIMPLEX, size, (255, 255, 255), text_thickness, cv2.LINE_AA)\n\n        cv2.putText(mask_img, caption, (x1, y1),\n                    cv2.FONT_HERSHEY_SIMPLEX, size, (255, 255, 255), text_thickness, cv2.LINE_AA)\n\n    return cv2.addWeighted(mask_img, mask_alpha, det_img, 1 - mask_alpha, 0)\n\n\ndef draw_comparison(img1, img2, name1, name2, fontsize=2.6, text_thickness=3):\n    (tw, th), _ = cv2.getTextSize(text=name1, fontFace=cv2.FONT_HERSHEY_DUPLEX,\n                                  fontScale=fontsize, thickness=text_thickness)\n    x1 = img1.shape[1] // 3\n    y1 = th\n    offset = th // 5\n    cv2.rectangle(img1, (x1 - offset * 2, y1 + offset),\n                  (x1 + tw + offset * 2, y1 - th - offset), (0, 115, 255), -1)\n    cv2.putText(img1, name1,\n                (x1, y1),\n                cv2.FONT_HERSHEY_DUPLEX, fontsize,\n                (255, 255, 255), text_thickness)\n\n\n    (tw, th), _ = cv2.getTextSize(text=name2, fontFace=cv2.FONT_HERSHEY_DUPLEX,\n                                  fontScale=fontsize, thickness=text_thickness)\n    x1 = img2.shape[1] // 3\n    y1 = th\n    offset = th // 5\n    cv2.rectangle(img2, (x1 - offset * 2, y1 + offset),\n                  (x1 + tw + offset * 2, y1 - th - offset), (94, 23, 235), -1)\n\n    cv2.putText(img2, name2,\n                (x1, y1),\n                cv2.FONT_HERSHEY_DUPLEX, fontsize,\n                (255, 255, 255), text_thickness)\n\n    combined_img = cv2.hconcat([img1, img2])\n    if combined_img.shape[1] > 3840:\n        combined_img = cv2.resize(combined_img, (3840, 2160))\n\n    return combined_img"
}