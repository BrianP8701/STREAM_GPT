{
    "metadata": {
        "type": "web",
        "url": "https://docs.llamaindex.ai/en/stable/examples/index_structs/struct_indices/SQLIndexDemo.html",
        "title": "Text-to-SQL Guide (Query Engine + Retriever) - LlamaIndex \ud83e\udd99 0.8.49",
        "description": null
    },
    "text": "Toggle table of contents sidebar\n\nThis is a basic guide to LlamaIndex\u2019s Text-to-SQL capabilities.\n\n1.  We first show how to perform text-to-SQL over a toy dataset: this will do \u201cretrieval\u201d (sql query over db) and \u201csynthesis\u201d.\n    \n2.  We then show how to buid a TableIndex over the schema to dynamically retrieve relevant tables during query-time.\n    \n3.  We finally show you how to define a text-to-SQL retriever on its own.\n    \n\nos.environ\\[\"OPENAI\\_API\\_KEY\"\\] \\= \"sk-..\"\nopenai.api\\_key \\= os.environ\\[\"OPENAI\\_API\\_KEY\"\\]\n\n\\# import logging\n\\# import sys\n\n\\# logging.basicConfig(stream=sys.stdout, level=logging.INFO)\n\\# logging.getLogger().addHandler(logging.StreamHandler(stream=sys.stdout))\n\nfrom IPython.display import Markdown, display\n\n## Create Database Schema[\uf0c1](#create-database-schema \"Permalink to this heading\")\n\nWe use `sqlalchemy`, a popular SQL database toolkit, to create an empty `city_stats` Table\n\nfrom sqlalchemy import (\n    create\\_engine,\n    MetaData,\n    Table,\n    Column,\n    String,\n    Integer,\n    select,\n)\n\nengine \\= create\\_engine(\"sqlite:///:memory:\")\nmetadata\\_obj \\= MetaData()\n\n\\# create city SQL table\ntable\\_name \\= \"city\\_stats\"\ncity\\_stats\\_table \\= Table(\n    table\\_name,\n    metadata\\_obj,\n    Column(\"city\\_name\", String(16), primary\\_key\\=True),\n    Column(\"population\", Integer),\n    Column(\"country\", String(16), nullable\\=False),\n)\nmetadata\\_obj.create\\_all(engine)\n\n## Define SQL Database[\uf0c1](#define-sql-database \"Permalink to this heading\")\n\nWe first define our `SQLDatabase` abstraction (a light wrapper around SQLAlchemy).\n\nfrom llama\\_index import SQLDatabase, ServiceContext\nfrom llama\\_index.llms import OpenAI\n\nllm \\= OpenAI(temperature\\=0.1, model\\=\"gpt-3.5-turbo\")\nservice\\_context \\= ServiceContext.from\\_defaults(llm\\=llm)\n\nsql\\_database \\= SQLDatabase(engine, include\\_tables\\=\\[\"city\\_stats\"\\])\n\nWe add some testing data to our SQL database.\n\nsql\\_database \\= SQLDatabase(engine, include\\_tables\\=\\[\"city\\_stats\"\\])\nfrom sqlalchemy import insert\n\nrows \\= \\[\n    {\"city\\_name\": \"Toronto\", \"population\": 2930000, \"country\": \"Canada\"},\n    {\"city\\_name\": \"Tokyo\", \"population\": 13960000, \"country\": \"Japan\"},\n    {\n        \"city\\_name\": \"Chicago\",\n        \"population\": 2679000,\n        \"country\": \"United States\",\n    },\n    {\"city\\_name\": \"Seoul\", \"population\": 9776000, \"country\": \"South Korea\"},\n\\]\nfor row in rows:\n    stmt \\= insert(city\\_stats\\_table).values(\\*\\*row)\n    with engine.begin() as connection:\n        cursor \\= connection.execute(stmt)\n\n\\# view current table\nstmt \\= select(\n    city\\_stats\\_table.c.city\\_name,\n    city\\_stats\\_table.c.population,\n    city\\_stats\\_table.c.country,\n).select\\_from(city\\_stats\\_table)\n\nwith engine.connect() as connection:\n    results \\= connection.execute(stmt).fetchall()\n    print(results)\n\n\\[('Toronto', 2930000, 'Canada'), ('Tokyo', 13960000, 'Japan'), ('Chicago', 2679000, 'United States'), ('Seoul', 9776000, 'South Korea')\\]\n\n## Query Index[\uf0c1](#query-index \"Permalink to this heading\")\n\nWe first show how we can execute a raw SQL query, which directly executes over the table.\n\nfrom sqlalchemy import text\n\nwith engine.connect() as con:\n    rows \\= con.execute(text(\"SELECT city\\_name from city\\_stats\"))\n    for row in rows:\n        print(row)\n\n('Chicago',)\n('Seoul',)\n('Tokyo',)\n('Toronto',)\n\n## Part 1: Text-to-SQL Query Engine[\uf0c1](#part-1-text-to-sql-query-engine \"Permalink to this heading\")\n\nOnce we have constructed our SQL database, we can use the NLSQLTableQueryEngine to construct natural language queries that are synthesized into SQL queries.\n\nNote that we need to specify the tables we want to use with this query engine. If we don\u2019t the query engine will pull all the schema context, which could overflow the context window of the LLM.\n\nfrom llama\\_index.indices.struct\\_store.sql\\_query import NLSQLTableQueryEngine\n\nquery\\_engine \\= NLSQLTableQueryEngine(\n    sql\\_database\\=sql\\_database,\n    tables\\=\\[\"city\\_stats\"\\],\n)\nquery\\_str \\= \"Which city has the highest population?\"\nresponse \\= query\\_engine.query(query\\_str)\n\ndisplay(Markdown(f\"<b>{response}</b>\"))\n\n**The city with the highest population is Tokyo.**\n\nThis query engine should used in any case where you can specify the tables you want to query over beforehand, or the total size of all the table schema plus the rest of the prompt fits your context window.\n\n## Part 2: Query-Time Retrieval of Tables for Text-to-SQL[\uf0c1](#part-2-query-time-retrieval-of-tables-for-text-to-sql \"Permalink to this heading\")\n\nIf we don\u2019t know ahead of time which table we would like to use, and the total size of the table schema overflows your context window size, we should store the table schema in an index so that during query time we can retrieve the right schema.\n\nThe way we can do this is using the SQLTableNodeMapping object, which takes in a SQLDatabase and produces a Node object for each SQLTableSchema object passed into the ObjectIndex constructor.\n\nfrom llama\\_index.indices.struct\\_store.sql\\_query import (\n    SQLTableRetrieverQueryEngine,\n)\nfrom llama\\_index.objects import (\n    SQLTableNodeMapping,\n    ObjectIndex,\n    SQLTableSchema,\n)\nfrom llama\\_index import VectorStoreIndex\n\n\\# set Logging to DEBUG for more detailed outputs\ntable\\_node\\_mapping \\= SQLTableNodeMapping(sql\\_database)\ntable\\_schema\\_objs \\= \\[\n    (SQLTableSchema(table\\_name\\=\"city\\_stats\"))\n\\]  \\# add a SQLTableSchema for each table\n\nobj\\_index \\= ObjectIndex.from\\_objects(\n    table\\_schema\\_objs,\n    table\\_node\\_mapping,\n    VectorStoreIndex,\n)\nquery\\_engine \\= SQLTableRetrieverQueryEngine(\n    sql\\_database, obj\\_index.as\\_retriever(similarity\\_top\\_k\\=1)\n)\n\nNow we can take our SQLTableRetrieverQueryEngine and query it for our response.\n\nresponse \\= query\\_engine.query(\"Which city has the highest population?\")\ndisplay(Markdown(f\"<b>{response}</b>\"))\n\n**The city with the highest population is Tokyo.**\n\n\\# you can also fetch the raw result from SQLAlchemy!\nresponse.metadata\\[\"result\"\\]\n\nYou can also add additional context information for each table schema you define.\n\n\\# manually set context text\ncity\\_stats\\_text \\= (\n    \"This table gives information regarding the population and country of a\"\n    \" given city.\\\\nThe user will query with codewords, where 'foo' corresponds\"\n    \" to population and 'bar'corresponds to city.\"\n)\n\ntable\\_node\\_mapping \\= SQLTableNodeMapping(sql\\_database)\ntable\\_schema\\_objs \\= \\[\n    (SQLTableSchema(table\\_name\\=\"city\\_stats\", context\\_str\\=city\\_stats\\_text))\n\\]\n\n## Part 3: Text-to-SQL Retriever[\uf0c1](#part-3-text-to-sql-retriever \"Permalink to this heading\")\n\nSo far our text-to-SQL capability is packaged in a query engine and consists of both retrieval and synthesis.\n\nYou can use the SQL retriever on its own. We show you some different parameters you can try, and also show how to plug it into our `RetrieverQueryEngine` to get roughly the same results.\n\nfrom llama\\_index.retrievers import NLSQLRetriever\n\n\\# default retrieval (return\\_raw=True)\nnl\\_sql\\_retriever \\= NLSQLRetriever(\n    sql\\_database, tables\\=\\[\"city\\_stats\"\\], return\\_raw\\=True\n)\n\nresults \\= nl\\_sql\\_retriever.retrieve(\n    \"Return the top 5 cities (along with their populations) with the highest population.\"\n)\n\nfrom llama\\_index.response.notebook\\_utils import display\\_source\\_node\n\nfor n in results:\n    display\\_source\\_node(n)\n\n**Node ID:** 458f723e-f1ac-4423-917a-522a71763390  \n**Similarity:** None  \n**Text:** \\[(\u2018Tokyo\u2019, 13960000), (\u2018Seoul\u2019, 9776000), (\u2018Toronto\u2019, 2930000), (\u2018Chicago\u2019, 2679000)\\]  \n\n\\# default retrieval (return\\_raw=False)\nnl\\_sql\\_retriever \\= NLSQLRetriever(\n    sql\\_database, tables\\=\\[\"city\\_stats\"\\], return\\_raw\\=False\n)\n\nresults \\= nl\\_sql\\_retriever.retrieve(\n    \"Return the top 5 cities (along with their populations) with the highest population.\"\n)\n\n\\# NOTE: all the content is in the metadata\nfor n in results:\n    display\\_source\\_node(n, show\\_source\\_metadata\\=True)\n\n**Node ID:** 7c0e4c94-c9a6-4917-aa3f-e3b3f4cbcd5c  \n**Similarity:** None  \n**Text:**  \n**Metadata:** {\u2018city\\_name\u2019: \u2018Tokyo\u2019, \u2018population\u2019: 13960000}  \n\n**Node ID:** 3c1d1caa-cec2-451e-8fd1-adc944e1d050  \n**Similarity:** None  \n**Text:**  \n**Metadata:** {\u2018city\\_name\u2019: \u2018Seoul\u2019, \u2018population\u2019: 9776000}  \n\n**Node ID:** fb9f9b25-b913-4dde-a0e3-6111f704aea9  \n**Similarity:** None  \n**Text:**  \n**Metadata:** {\u2018city\\_name\u2019: \u2018Toronto\u2019, \u2018population\u2019: 2930000}  \n\n**Node ID:** c31ba8e7-de5d-4f28-a464-5e0339547c70  \n**Similarity:** None  \n**Text:**  \n**Metadata:** {\u2018city\\_name\u2019: \u2018Chicago\u2019, \u2018population\u2019: 2679000}  \n\n### Plug into our `RetrieverQueryEngine`[\uf0c1](#plug-into-our-retrieverqueryengine \"Permalink to this heading\")\n\nWe compose our SQL Retriever with our standard `RetrieverQueryEngine` to synthesize a response. The result is roughly similar to our packaged `Text-to-SQL` query engines.\n\nfrom llama\\_index.query\\_engine import RetrieverQueryEngine\n\nquery\\_engine \\= RetrieverQueryEngine.from\\_args(nl\\_sql\\_retriever)\n\nresponse \\= query\\_engine.query(\n    \"Return the top 5 cities (along with their populations) with the highest population.\"\n)\n\nThe top 5 cities with the highest population are:\n\n1. Tokyo - 13,960,000\n2. Seoul - 9,776,000\n3. Toronto - 2,930,000\n4. Chicago - 2,679,000"
}