{
    "metadata": {
        "type": "repo",
        "path": "stream_gpt/knowledge_tree/tree/tree_class.py"
    },
    "text": "import json\nfrom graphviz import Digraph\n\nclass Knowledge_Tree:\n    '''\n        This is a standard tree data structure, with the addition of a data field for each node.\n    '''\n    def __init__(self):\n        self.nodes = {}\n        self.root = None\n\n    def add_node(self, node_id, parent_id=None, data=None):\n        '''\n        Add a node to the tree.\n        \n        Parameters:\n            node_id: Unique identifier for the node.\n            parent_id: Identifier of the parent node (None for root).\n            data: Data to be stored in the node.\n        \n        Raises:\n            ValueError: If the node_id already exists or the parent_id does not exist.\n        '''\n        if node_id in self.nodes:\n            raise ValueError(f\"Node {node_id} already exists.\")\n        if parent_id and parent_id not in self.nodes:\n            raise ValueError(f\"Parent node {parent_id} does not exist.\")\n        \n        self.nodes[node_id] = {\"data\": data, \"children\": [], \"parent\": parent_id}\n        if parent_id:\n            self.nodes[parent_id][\"children\"].append(node_id)\n\n    def remove_node(self, node_id):\n        '''\n        Remove a node and all its children from the tree.\n        \n        Parameters:\n            node_id: Identifier of the node to be removed.\n        '''\n        children = self.nodes[node_id][\"children\"]\n        for child in children:\n            self.remove_node(child)\n        \n        parent_id = self.nodes[node_id][\"parent\"]\n        if parent_id:\n            self.nodes[parent_id][\"children\"].remove(node_id)\n        del self.nodes[node_id]\n            \n    def add_nodes(self, parent_ids, children_ids_list, data_list=None):\n        '''\n        Adds multiple nodes to the tree.\n        \n        Parameters:\n            parent_ids: List of identifiers for the parent nodes.\n            children_ids_list: List of lists, each containing identifiers for children of a parent.\n            data_list: List of data to be stored in the nodes. Defaults to None.\n        \n        Note:\n            The lengths of parent_ids, children_ids_list, and data_list must be the same.\n        '''\n        if data_list is None:\n            data_list = [None] * len(parent_ids)\n        for parent_id, children_ids, data in zip(parent_ids, children_ids_list, data_list):\n            for child_id in children_ids:\n                self.add_node(child_id, parent_id, data)\n\n    def add_parent(self, parent_id, children_ids, data=None):\n        '''\n        Adds a parent node and its children.\n        \n        Parameters:\n            parent_id: Identifier of the parent node.\n            children_ids: List of identifiers for the child nodes.\n            data: Data to be stored in the parent and child nodes.\n        '''\n        if parent_id not in self.nodes:\n            self.nodes[parent_id] = {\"data\": data, \"children\": [], \"parent\": None}\n        for child_id in children_ids:\n            if self.nodes[child_id][\"parent\"]:\n                raise ValueError(f\"Child node {child_id} already has a parent.\")\n            else:\n                self.nodes[child_id][\"parent\"] = parent_id\n                self.nodes[parent_id][\"children\"].append(child_id)\n            \n    def add_layer(self, node_ids, data_list=None):\n        '''\n        Adds a layer of nodes without connecting them to any parents.\n        \n        Parameters:\n            node_ids: List of identifiers for the nodes.\n            data_list: List of data to be stored in the nodes. Defaults to None.\n        '''\n        if data_list is None:\n            data_list = [None] * len(node_ids)\n        for node_id, data in zip(node_ids, data_list):\n            self.add_node(node_id, data=data)\n    \n    def save_to_file(self, file_path):\n        '''\n        Save the tree to a file in JSON format.\n        \n        Parameters:\n            file_path: The path to the file where the tree will be saved.\n        '''\n        with open(file_path, 'w') as f:\n            json.dump(self.nodes, f)\n\n    def load_from_file(self, file_path):\n        '''\n        Load the tree from a file.\n        \n        Parameters:\n            file_path: The path to the file from which to load the tree.\n        \n        Note:\n            This will overwrite any existing data in the tree.\n        '''\n        with open(file_path, 'r') as f:\n            self.nodes = json.load(f)\n\n    def to_graphviz(self, file_path='knowledge_tree'):\n        '''\n        Generate a Graphviz representation of the tree and render it.\n        \n        Parameters:\n            file_path: The path where the Graphviz file will be saved. Defaults to 'knowledge_tree'.\n        '''\n        dot = Digraph()\n        for node_id, node_data in self.nodes.items():\n            label = f\"{node_id}\\n{node_data['data']}\"\n            dot.node(node_id, label=label)\n            for child_id in node_data['children']:\n                dot.edge(node_id, child_id)\n        dot.render(file_path, view=True)\n\n            \nclass Global_Knowledge_Tree(Knowledge_Tree):\n    '''\n        This is the same as Knowledge_Tree, but with a list of root nodes of branches within the tree\n        that represent individual documents.\n    '''\n    def __init__(self):\n        super().__init__() \n        self.document_roots = []  \n        self.add_node('Global Root Node')\n        self.root = 'Global Root Node'\n        \n    def add_knowledge_tree(self, subtree):\n        current_node = self.root\n        document_root_data = subtree.nodes[subtree.root]['data']\n        for node in subtree.nodes:\n            self.add_node(node, data=subtree.nodes[node]['data'])\n        traversing_tree = True\n        while(traversing_tree):\n            if self.are_all_children_documents(current_node):\n                traversing_tree = False\n                self.add_node(subtree.root, current_node)\n            else:\n                current_node = subtree.nodes[current_node]['children'][0]\n                \n    def are_all_children_documents(self, node_id):\n        return all(child in self.document_roots for child in self.nodes[node_id]['children'])"
}