{
    "metadata": {
        "type": "web",
        "url": "https://docs.llamaindex.ai/en/stable/examples/query_engine/pgvector_sql_query_engine.html",
        "title": "[Beta] Text-to-SQL with PGVector - LlamaIndex \ud83e\udd99 0.8.49",
        "description": null
    },
    "text": "[Back to top](#)\n\nToggle table of contents sidebar\n\n## \\[Beta\\] Text-to-SQL with PGVector[\uf0c1](#beta-text-to-sql-with-pgvector \"Permalink to this heading\")\n\nThis notebook demo shows how to perform text-to-SQL with pgvector. This allows us to jointly do both semantic search and structured querying, _all_ within SQL!\n\nThis hypothetically enables more expressive queries than semantic search + metadata filters.\n\n**NOTE**: This is a beta feature, interfaces might change. But in the meantime hope you find it useful!\n\n## Setup Data[\uf0c1](#setup-data \"Permalink to this heading\")\n\n### Load Documents[\uf0c1](#load-documents \"Permalink to this heading\")\n\nLoad in the Lyft 2021 10k document.\n\nfrom llama\\_hub.file.pdf.base import PDFReader\n\ndocs \\= reader.load\\_data(\"../data/10k/lyft\\_2021.pdf\")\n\nfrom llama\\_index.node\\_parser import SimpleNodeParser\n\nnode\\_parser \\= SimpleNodeParser.from\\_defaults()\nnodes \\= node\\_parser.get\\_nodes\\_from\\_documents(docs)\n\nprint(nodes\\[8\\].get\\_content(metadata\\_mode\\=\"all\"))\n\n### Insert data into Postgres + PGVector[\uf0c1](#insert-data-into-postgres-pgvector \"Permalink to this heading\")\n\nMake sure you have all the necessary dependencies installed!\n\n!pip install psycopg2-binary pgvector asyncpg \"sqlalchemy\\[asyncio\\]\" greenlet\n\nfrom pgvector.sqlalchemy import Vector\nfrom sqlalchemy import insert, create\\_engine, String, text, Integer\nfrom sqlalchemy.orm import declarative\\_base, mapped\\_column\n\n#### Establish Connection[\uf0c1](#establish-connection \"Permalink to this heading\")\n\nengine \\= create\\_engine(\"postgresql+psycopg2://localhost/postgres\")\nwith engine.connect() as conn:\n    conn.execute(text(\"CREATE EXTENSION IF NOT EXISTS vector\"))\n    conn.commit()\n\n#### Define Table Schema[\uf0c1](#define-table-schema \"Permalink to this heading\")\n\nDefine as Python class. Note we store the page\\_label, embedding, and text.\n\nBase \\= declarative\\_base()\n\nclass SECTextChunk(Base):\n    \\_\\_tablename\\_\\_ \\= \"sec\\_text\\_chunk\"\n\n    id \\= mapped\\_column(Integer, primary\\_key\\=True)\n    page\\_label \\= mapped\\_column(Integer)\n    file\\_name \\= mapped\\_column(String)\n    text \\= mapped\\_column(String)\n    embedding \\= mapped\\_column(Vector(384))\n\nBase.metadata.drop\\_all(engine)\nBase.metadata.create\\_all(engine)\n\n#### Generate embedding for each Node with a sentence\\_transformers model[\uf0c1](#generate-embedding-for-each-node-with-a-sentence-transformers-model \"Permalink to this heading\")\n\n\\# get embeddings for each row\nfrom llama\\_index.embeddings import HuggingFaceEmbedding\n\nembed\\_model \\= HuggingFaceEmbedding(model\\_name\\=\"BAAI/bge-small-en\")\n\nfor node in nodes:\n    text\\_embedding \\= embed\\_model.get\\_text\\_embedding(node.get\\_content())\n    node.embedding \\= text\\_embedding\n\n#### Insert into Database[\uf0c1](#insert-into-database \"Permalink to this heading\")\n\n\\# insert into database\nfor node in nodes:\n    row\\_dict \\= {\n        \"text\": node.get\\_content(),\n        \"embedding\": node.embedding,\n        \\*\\*node.metadata,\n    }\n    stmt \\= insert(SECTextChunk).values(\\*\\*row\\_dict)\n    with engine.connect() as connection:\n        cursor \\= connection.execute(stmt)\n        connection.commit()\n\n## Define PGVectorSQLQueryEngine[\uf0c1](#define-pgvectorsqlqueryengine \"Permalink to this heading\")\n\nNow that we\u2019ve loaded the data into the database, we\u2019re ready to setup our query engine.\n\n### Define Prompt[\uf0c1](#define-prompt \"Permalink to this heading\")\n\nWe create a modified version of our default text-to-SQL prompt to inject awareness of the pgvector syntax. We also prompt it with some few-shot examples of how to use the syntax (<\u2013>).\n\n**NOTE**: This is included by default in the `PGVectorSQLQueryEngine`, we included it here mostly for visibility!\n\nfrom llama\\_index.prompts import PromptTemplate\n\ntext\\_to\\_sql\\_tmpl \\= \"\"\"\\\\\nGiven an input question, first create a syntactically correct {dialect} \\\\\nquery to run, then look at the results of the query and return the answer. \\\\\nYou can order the results by a relevant column to return the most \\\\\ninteresting examples in the database.\n\nPay attention to use only the column names that you can see in the schema \\\\\ndescription. Be careful to not query for columns that do not exist. \\\\\nPay attention to which column is in which table. Also, qualify column names \\\\\nwith the table name when needed. \n\nIMPORTANT NOTE: you can use specialized pgvector syntax (\\`<->\\`) to do nearest \\\\\nneighbors/semantic search to a given vector from an embeddings column in the table. \\\\\nThe embeddings value for a given row typically represents the semantic meaning of that row. \\\\\nThe vector represents an embedding representation \\\\\nof the question, given below. Do NOT fill in the vector values directly, but rather specify a \\\\\n\\`\\[query\\_vector\\]\\` placeholder. For instance, some select statement examples below \\\\\n(the name of the embeddings column is \\`embedding\\`):\nSELECT \\* FROM items ORDER BY embedding <-> '\\[query\\_vector\\]' LIMIT 5;\nSELECT \\* FROM items WHERE id != 1 ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;\nSELECT \\* FROM items WHERE embedding <-> '\\[query\\_vector\\]' < 5;\n\nYou are required to use the following format, \\\\\neach taking one line:\n\nQuestion: Question here\nSQLQuery: SQL Query to run\nSQLResult: Result of the SQLQuery\nAnswer: Final answer here\n\nOnly use tables listed below.\n{schema}\n\nQuestion: {query\\_str}\nSQLQuery: \\\\\n\"\"\"\ntext\\_to\\_sql\\_prompt \\= PromptTemplate(text\\_to\\_sql\\_tmpl)\n\n### Setup LLM, Embedding Model, and Misc.[\uf0c1](#setup-llm-embedding-model-and-misc \"Permalink to this heading\")\n\nBesides LLM and embedding model, note we also add annotations on the table itself. This better helps the LLM understand the column schema (e.g. by telling it what the embedding column represents) to better do either tabular querying or semantic search.\n\nfrom llama\\_index import ServiceContext, SQLDatabase\nfrom llama\\_index.llms import OpenAI\nfrom llama\\_index.query\\_engine import PGVectorSQLQueryEngine\n\nsql\\_database \\= SQLDatabase(engine, include\\_tables\\=\\[\"sec\\_text\\_chunk\"\\])\n\nllm \\= OpenAI(model\\=\"gpt-4\")\nservice\\_context \\= ServiceContext.from\\_defaults(\n    llm\\=llm, embed\\_model\\=embed\\_model\n)\n\ntable\\_desc \\= \"\"\"\\\\\nThis table represents text chunks from an SEC filing. Each row contains the following columns:\n\nid: id of row\npage\\_label: page number \nfile\\_name: top-level file name\ntext: all text chunk is here\nembedding: the embeddings representing the text chunk\n\nFor most queries you should perform semantic search against the \\`embedding\\` column values, since \\\\\nthat encodes the meaning of the text.\n\n\"\"\"\n\ncontext\\_query\\_kwargs \\= {\"sec\\_text\\_chunk\": table\\_desc}\n\n### Define Query Engine[\uf0c1](#define-query-engine \"Permalink to this heading\")\n\nquery\\_engine \\= PGVectorSQLQueryEngine(\n    sql\\_database\\=sql\\_database,\n    text\\_to\\_sql\\_prompt\\=text\\_to\\_sql\\_prompt,\n    service\\_context\\=service\\_context,\n    context\\_query\\_kwargs\\=context\\_query\\_kwargs,\n)\n\n## Run Some Queries[\uf0c1](#run-some-queries \"Permalink to this heading\")\n\nNow we\u2019re ready to run some queries\n\nresponse \\= query\\_engine.query(\n    \"Can you tell me about the risk factors described in page 6?\",\n)\n\nPage 6 discusses the impact of the COVID-19 pandemic on the business. It mentions that the pandemic has affected communities in the United States, Canada, and globally. The pandemic has led to a significant decrease in the demand for ridesharing services, which has negatively impacted the company's financial performance. The page also discusses the company's efforts to adapt to the changing environment by focusing on the delivery of essential goods and services. Additionally, it mentions the company's transportation network, which offers riders seamless, personalized, and on-demand access to a variety of mobility options.\n\nprint(response.metadata\\[\"sql\\_query\"\\])\n\nresponse \\= query\\_engine.query(\n    \"Tell me more about Lyft's real estate operating leases\",\n)\n\nLyft's lease arrangements include vehicle rental programs, office space, and data centers. Leases that do not meet any specific criteria are accounted for as operating leases. The lease term begins when Lyft is available to use the underlying asset and ends upon the termination of the lease. The lease term includes any periods covered by an option to extend if Lyft is reasonably certain to exercise that option. Leasehold improvements are amortized on a straight-line basis over the shorter of the term of the lease, or the useful life of the assets.\n\nprint(response.metadata\\[\"sql\\_query\"\\]\\[:300\\])\n\nSELECT \\* FROM sec\\_text\\_chunk WHERE text LIKE '%Lyft%' AND text LIKE '%real estate%' AND text LIKE '%operating leases%' ORDER BY embedding <-> '\\[-0.007079003844410181, -0.04383348673582077, 0.02910166047513485, 0.02049737051129341, 0.009460929781198502, -0.017539210617542267, 0.04225028306245804, 0.0\n\n\\# looked at returned result\nprint(response.metadata\\[\"result\"\\])\n\n\\[(157, 93, 'lyft\\_2021.pdf', \"Leases that do not meet any of the above criteria are accounted for as operating leases.Lessor\\\\nThe\\\\n Company's lease arrangements include vehicle re ... (4356 characters truncated) ...  realized. Leasehold improvements are amortized on a straight-line basis over the shorter of the term of the lease, or the useful life of the assets.\", '\\[0.017818017,-0.024016099,0.0042511695,0.03114478,0.003591422,-0.0097886855,0.02455732,0.013048866,0.018157514,-0.009401044,0.031699456,0.01678178,0. ... (4472 characters truncated) ... 6,0.01127416,0.045080125,-0.017046565,-0.028544193,-0.016320521,0.01062995,-0.021007432,-0.006999497,-0.08426073,-0.014918887,0.059064835,0.03307945\\]')\\]\n\n\\# structured query\nresponse \\= query\\_engine.query(\n    \"Tell me about the max page number in this table\",\n)\n\nThe maximum page number in this table is 238.\n\nprint(response.metadata\\[\"sql\\_query\"\\]\\[:300\\])\n\nSELECT MAX(page\\_label) FROM sec\\_text\\_chunk;"
}