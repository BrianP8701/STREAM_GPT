{
    "metadata": {
        "type": "web",
        "url": "https://docs.llamaindex.ai/en/stable/end_to_end_tutorials/dev_practices/production_rag.html",
        "title": "Building Performant RAG Applications for Production - LlamaIndex \ud83e\udd99 0.8.49",
        "description": null
    },
    "text": "[Back to top](#)\n\nToggle table of contents sidebar\n\nPrototyping a RAG application is easy, but making it performant, robust, and scalable to a large knowledge corpus is hard.\n\nThis guide contains a variety of tips and tricks to improve the performance of your RAG pipeline. We first outline some general techniques - they are loosely ordered in terms of most straightforward to most challenging. We then dive a bit more deeply into each technique, the use cases that it solves, and how to implement it with LlamaIndex!\n\nThe end goal is to optimize your retrieval and generation performance to answer more queries over more complex datasets accurately and without hallucinations.\n\n## General Techniques for Building Production-Grade RAG[\uf0c1](#general-techniques-for-building-production-grade-rag \"Permalink to this heading\")\n\nHere are some top Considerations for Building Production-Grade RAG\n\n*   Decoupling chunks used for retrieval vs. chunks used for synthesis\n    \n*   Structured Retrieval for Larger Document Sets\n    \n*   Dynamically Retrieve Chunks Depending on your Task\n    \n*   Optimize context embeddings\n    \n\nWe discussed this and more during our [Production RAG Webinar](https://www.youtube.com/watch?v=Zj5RCweUHIk). Check out [this Tweet thread](https://twitter.com/jerryjliu0/status/1692931028963221929?s=20) for more synthesized details.\n\n## Decoupling Chunks Used for Retrieval vs. Chunks Used for Synthesis[\uf0c1](#decoupling-chunks-used-for-retrieval-vs-chunks-used-for-synthesis \"Permalink to this heading\")\n\nA key technique for better retrieval is to decouple chunks used for retrieval with those that are used for synthesis.\n\n![](https://docs.llamaindex.ai/en/stable/_images/decouple_chunks.png)\n\n### Motivation[\uf0c1](#motivation \"Permalink to this heading\")\n\nThe optimal chunk representation for retrieval might be different than the optimal consideration used for synthesis. For instance, a raw text chunk may contain needed details for the LLM to synthesize a more detailed answer given a query. However, it may contain filler words/info that may bias the embedding representation, or it may lack global context and not be retrieved at all when a relevant query comes in.\n\n### Key Techniques[\uf0c1](#key-techniques \"Permalink to this heading\")\n\nThere\u2019s two main ways to take advantage of this idea:\n\n**1\\. Embed a document summary, which links to chunks associated with the document.**\n\nThis can help retrieve relevant documents at a high-level before retrieving chunks vs. retrieving chunks directly (that might be in irrelevant documents).\n\nResources:\n\n*   [Recursive Retriever + Query Engine Demo](https://docs.llamaindex.ai/en/stable/examples/query_engine/pdf_tables/recursive_retriever.html)\n*   [Document Summary Index](https://docs.llamaindex.ai/en/stable/examples/index_structs/doc_summary/DocSummary.html)\n\n**2\\. Embed a sentence, which then links to a window around the sentence.**\n\nThis allows for finer-grained retrieval of relevant context (embedding giant chunks leads to \u201clost in the middle\u201d problems), but also ensures enough context for LLM synthesis.\n\nResources:\n\n*   [Metadata Replacement + Node Sentence Window](https://docs.llamaindex.ai/en/stable/examples/node_postprocessor/MetadataReplacementDemo.html)\n\n## Structured Retrieval for Larger Document Sets[\uf0c1](#structured-retrieval-for-larger-document-sets \"Permalink to this heading\")\n\n![](https://docs.llamaindex.ai/en/stable/_images/structured_retrieval.png)\n\n### Motivation[\uf0c1](#id1 \"Permalink to this heading\")\n\nA big issue with the standard RAG stack (top-k retrieval + basic text splitting) is that it doesn\u2019t do well as the number of documents scales up - e.g. if you have 100 different PDFs. In this setting, given a query you may want to use structured information to help with more precise retrieval; for instance, if you ask a question that\u2019s only relevant to two PDFs, using structured information to ensure those two PDFs get returned beyond raw embedding similarity with chunks.\n\n### Key Techniques[\uf0c1](#id2 \"Permalink to this heading\")\n\nThere\u2019s a few ways of performing more structured tagging/retrieval for production-quality RAG systems, each with their own pros/cons.\n\n**1\\. Metadata Filters + Auto Retrieval** Tag each document with metadata and then store in a vector database. During inference time, use the LLM to infer the right metadata filters to query the vector db in addition to the semantic query string.\n\n*   Pros \u2705: Supported in major vector dbs. Can filter document via multiple dimensions.\n    \n*   Cons \ud83d\udeab: Can be hard to define the right tags. Tags may not contain enough relevant information for more precise retrieval. Also tags represent keyword search at the document-level, doesn\u2019t allow for semantic lookups.\n    \n\nResources: **2\\. Store Document Hierarchies (summaries -> raw chunks) + Recursive Retrieval** Embed document summaries and map to chunks per document. Fetch at the document-level first before chunk level.\n\n*   Pros \u2705: Allows for semantic lookups at the document level.\n    \n*   Cons \ud83d\udeab: Doesn\u2019t allow for keyword lookups by structured tags (can be more precise than semantic search). Also autogenerating summaries can be expensive.\n    \n\n**Resources**\n\n*   [Auto-Retrieval from a Vector Database](https://docs.llamaindex.ai/en/stable/examples/vector_stores/chroma_auto_retriever.html)\n*   [Document Summary Index](https://docs.llamaindex.ai/en/stable/examples/index_structs/doc_summary/DocSummary.html)\n*   [Recursive Retriever + Document Agents](https://docs.llamaindex.ai/en/stable/examples/query_engine/recursive_retriever_agents.html)\n*   [Comparing Methods for Structured Retrieval (Auto-Retrieval vs. Recursive Retrieval)](https://docs.llamaindex.ai/en/stable/examples/retrievers/auto_vs_recursive_retriever.html)\n\n## Dynamically Retrieve Chunks Depending on your Task[\uf0c1](#dynamically-retrieve-chunks-depending-on-your-task \"Permalink to this heading\")\n\n![](https://docs.llamaindex.ai/en/stable/_images/joint_qa_summary.png)\n\n### Motivation[\uf0c1](#id3 \"Permalink to this heading\")\n\nRAG isn\u2019t just about question-answering about specific facts, which top-k similarity is optimized for. There can be a broad range of queries that a user might ask. Queries that are handled by naive RAG stacks include ones that ask about specific facts e.g. \u201cTell me about the D&I initiatives for this company in 2023\u201d or \u201cWhat did the narrator do during his time at Google\u201d. But queries can also include summarization e.g. \u201cCan you give me a high-level overview of this document\u201d, or comparisons \u201cCan you compare/contrast X and Y\u201d. All of these use cases may require different retrieval techniques.\n\n## Optimize Context Embeddings[\uf0c1](#optimize-context-embeddings \"Permalink to this heading\")\n\n### Motivation[\uf0c1](#id5 \"Permalink to this heading\")\n\nThis is related to the motivation described above in \u201cdecoupling chunks used for retrieval vs. synthesis\u201d. We want to make sure that the embeddings are optimized for better retrieval over your specific data corpus. Pre-trained models may not capture the salient properties of the data relevant to your use case.\n\n### Key Techniques[\uf0c1](#id6 \"Permalink to this heading\")\n\nBeyond some of the techniques listed above, we can also try finetuning the embedding model. We can actually do this over an unstructured text corpus, in a label-free way.\n\nCheck out our guides here:\n\n*   [Embedding Fine-tuning Guide](https://docs.llamaindex.ai/en/stable/examples/finetuning/embeddings/finetune_embedding.html)"
}