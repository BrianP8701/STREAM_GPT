{
    "metadata": {
        "type": "web",
        "url": "https://platform.openai.com/docs/guides/gpt/should-i-use-chatgpt-or-the-api",
        "title": "GPT - OpenAI API",
        "description": "Explore resources, tutorials, API docs, and dynamic examples to get the most out of OpenAI's developer platform."
    },
    "text": "[](https://platform.openai.com/docs/guides/gpt/gpt-models)\n\n## [GPT models](https://platform.openai.com/docs/guides/gpt/gpt-models)\n\nOpenAI's GPT (generative pre-trained transformer) models have been trained to understand natural language and code. GPTs provide text outputs in response to their inputs. The inputs to GPTs are also referred to as \"prompts\". Designing a prompt is essentially how you \u201cprogram\u201d a GPT model, usually by providing instructions or some examples of how to successfully complete a task.\n\nUsing GPTs, you can build applications to:\n\n*   Draft documents\n*   Write computer code\n*   Answer questions about a knowledge base\n*   Analyze texts\n*   Create conversational agents\n*   Give software a natural language interface\n*   Tutor in a range of subjects\n*   Translate languages\n*   Simulate characters for games\n\n...and much more!\n\nTo use a GPT model via the OpenAI API, you\u2019ll send a request containing the inputs and your API key, and receive a response containing the model\u2019s output. Our latest models, `gpt-4` and `gpt-3.5-turbo`, are accessed through the chat completions API endpoint.\n\n|     | Model families | API endpoint |\n| --- | --- | --- |\n| Newer models (2023\u2013) | gpt-4, gpt-3.5-turbo | [https://api.openai.com/v1/chat/completions](https://api.openai.com/v1/chat/completions) |\n| Updated base models (2023) | babbage-002, davinci-002 | [https://api.openai.com/v1/completions](https://api.openai.com/v1/completions) |\n| Legacy models (2020\u20132022) | text-davinci-003, text-davinci-002, davinci, curie, babbage, ada | [https://api.openai.com/v1/completions](https://api.openai.com/v1/completions) |\n\nYou can experiment with GPTs in the [playground](https://platform.openai.com/playground?mode=chat). If you\u2019re not sure which model to use, then use `gpt-3.5-turbo` or `gpt-4`.\n\n[](https://platform.openai.com/docs/guides/gpt/chat-completions-api)\n\n## [Chat completions API](https://platform.openai.com/docs/guides/gpt/chat-completions-api)\n\nChat models take a list of messages as input and return a model-generated message as output. Although the chat format is designed to make multi-turn conversations easy, it\u2019s just as useful for single-turn tasks without any conversation.\n\nAn example Chat completions API call looks like the following:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\nresponse = openai.ChatCompletion.create(\n    model=\"gpt-3.5-turbo\",\n    messages=[\n        {\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n        {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"},\n        {\"role\": \"assistant\", \"content\": \"The Los Angeles Dodgers won the World Series in 2020.\"},\n        {\"role\": \"user\", \"content\": \"Where was it played?\"}\n    ]\n)\n```\n\nTo learn more, you can view the full [API reference documentation](https://platform.openai.com/docs/api-reference/chat) for the Chat API.\n\nThe main input is the messages parameter. Messages must be an array of message objects, where each object has a role (either \"system\", \"user\", or \"assistant\") and content. Conversations can be as short as one message or many back and forth turns.\n\nTypically, a conversation is formatted with a system message first, followed by alternating user and assistant messages.\n\nThe system message helps set the behavior of the assistant. For example, you can modify the personality of the assistant or provide specific instructions about how it should behave throughout the conversation. However note that the system message is optional and the model\u2019s behavior without a system message is likely to be similar to using a generic message such as \"You are a helpful assistant.\"\n\nThe user messages provide requests or comments for the assistant to respond to. Assistant messages store previous assistant responses, but can also be written by you to give examples of desired behavior.\n\nIncluding conversation history is important when user instructions refer to prior messages. In the example above, the user\u2019s final question of \"Where was it played?\" only makes sense in the context of the prior messages about the World Series of 2020. Because the models have no memory of past requests, all relevant information must be supplied as part of the conversation history in each request. If a conversation cannot fit within the model\u2019s token limit, it will need to be [shortened](https://platform.openai.com/docs/guides/gpt-best-practices/tactic-for-dialogue-applications-that-require-very-long-conversations-summarize-or-filter-previous-dialogue) in some way.\n\nTo mimic the effect seen in ChatGPT where the text is returned iteratively, set the [stream](https://platform.openai.com/docs/api-reference/chat/create#chat/create-stream) parameter to true.\n\n[](https://platform.openai.com/docs/guides/gpt/chat-completions-response-format)\n\n### [Chat completions response format](https://platform.openai.com/docs/guides/gpt/chat-completions-response-format)\n\nAn example Chat completions API response looks as follows:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"choices\": [\n    {\n      \"finish_reason\": \"stop\",\n      \"index\": 0,\n      \"message\": {\n        \"content\": \"The 2020 World Series was played in Texas at Globe Life Field in Arlington.\",\n        \"role\": \"assistant\"\n      }\n    }\n  ],\n  \"created\": 1677664795,\n  \"id\": \"chatcmpl-7QyqpwdfhqwajicIEznoc6Q47XAyW\",\n  \"model\": \"gpt-3.5-turbo-0613\",\n  \"object\": \"chat.completion\",\n  \"usage\": {\n    \"completion_tokens\": 17,\n    \"prompt_tokens\": 57,\n    \"total_tokens\": 74\n  }\n}\n```\n\nThe assistant\u2019s reply can be extracted with:\n\n```\nresponse['choices'][0]['message']['content']\n```\n\nEvery response will include a `finish_reason`. The possible values for `finish_reason` are:\n\n*   `stop`: API returned complete message, or a message terminated by one of the stop sequences provided via the [stop](https://platform.openai.com/docs/api-reference/chat/create#chat/create-stop) parameter\n*   `length`: Incomplete model output due to [`max_tokens`](https://platform.openai.com/docs/api-reference/chat/create#chat/create-max_tokens) parameter or token limit\n*   `function_call`: The model decided to call a function\n*   `content_filter`: Omitted content due to a flag from our content filters\n*   `null`: API response still in progress or incomplete\n\nDepending on input parameters (like providing functions as shown below), the model response may include different information.\n\n[](https://platform.openai.com/docs/guides/gpt/function-calling)\n\n## [Function calling](https://platform.openai.com/docs/guides/gpt/function-calling)\n\nIn an API call, you can describe functions to `gpt-3.5-turbo-0613` and `gpt-4-0613`, and have the model intelligently choose to output a JSON object containing arguments to call those functions. The Chat completions API does not call the function; instead, the model generates JSON that you can use to call the function in your code.\n\nThe latest models (`gpt-3.5-turbo-0613` and `gpt-4-0613`) have been fine-tuned to both detect when a function should to be called (depending on the input) and to respond with JSON that adheres to the function signature. With this capability also comes potential risks. We strongly recommend building in user confirmation flows before taking actions that impact the world on behalf of users (sending an email, posting something online, making a purchase, etc).\n\nUnder the hood, functions are injected into the system message in a syntax the model has been trained on. This means functions count against the model's context limit and are billed as input tokens. If running into context limits, we suggest limiting the number of functions or the length of documentation you provide for function parameters.\n\nFunction calling allows you to more reliably get structured data back from the model. For example, you can:\n\n*   Create chatbots that answer questions by calling external APIs (e.g. like ChatGPT Plugins)\n    *   e.g. define functions like `send_email(to: string, body: string)`, or `get_current_weather(location: string, unit: 'celsius' | 'fahrenheit')`\n*   Convert natural language into API calls\n    *   e.g. convert \"Who are my top customers?\" to `get_customers(min_revenue: int, created_before: string, limit: int)` and call your internal API\n*   Extract structured data from text\n    *   e.g. define a function called `extract_data(name: string, birthday: string)`, or `sql_query(query: string)`\n\n...and much more!\n\nThe basic sequence of steps for function calling is as follows:\n\n1.  Call the model with the user query and a set of functions defined in the [functions parameter](https://platform.openai.com/docs/api-reference/chat/create#chat/create-functions).\n2.  The model can choose to call a function; if so, the content will be a stringified JSON object adhering to your custom schema (note: the model may generate invalid JSON or hallucinate parameters).\n3.  Parse the string into JSON in your code, and call your function with the provided arguments if they exist.\n4.  Call the model again by appending the function response as a new message, and let the model summarize the results back to the user.\n\nYou can see these steps in action through the example below:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\nimport openai\nimport json\n\n# Example dummy function hard coded to return the same weather\n# In production, this could be your backend API or an external API\ndef get_current_weather(location, unit=\"fahrenheit\"):\n    \"\"\"Get the current weather in a given location\"\"\"\n    weather_info = {\n        \"location\": location,\n        \"temperature\": \"72\",\n        \"unit\": unit,\n        \"forecast\": [\"sunny\", \"windy\"],\n    }\n    return json.dumps(weather_info)\n\ndef run_conversation():\n    # Step 1: send the conversation and available functions to GPT\n    messages = [{\"role\": \"user\", \"content\": \"What's the weather like in Boston?\"}]\n    functions = [\n        {\n            \"name\": \"get_current_weather\",\n            \"description\": \"Get the current weather in a given location\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"location\": {\n                        \"type\": \"string\",\n                        \"description\": \"The city and state, e.g. San Francisco, CA\",\n                    },\n                    \"unit\": {\"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"]},\n                },\n                \"required\": [\"location\"],\n            },\n        }\n    ]\n    response = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo-0613\",\n        messages=messages,\n        functions=functions,\n        function_call=\"auto\",  # auto is default, but we'll be explicit\n    )\n    response_message = response[\"choices\"][0][\"message\"]\n\n    # Step 2: check if GPT wanted to call a function\n    if response_message.get(\"function_call\"):\n        # Step 3: call the function\n        # Note: the JSON response may not always be valid; be sure to handle errors\n        available_functions = {\n            \"get_current_weather\": get_current_weather,\n        }  # only one function in this example, but you can have multiple\n        function_name = response_message[\"function_call\"][\"name\"]\n        function_to_call = available_functions[function_name]\n        function_args = json.loads(response_message[\"function_call\"][\"arguments\"])\n        function_response = function_to_call(\n            location=function_args.get(\"location\"),\n            unit=function_args.get(\"unit\"),\n        )\n\n        # Step 4: send the info on the function call and function response to GPT\n        messages.append(response_message)  # extend conversation with assistant's reply\n        messages.append(\n            {\n                \"role\": \"function\",\n                \"name\": function_name,\n                \"content\": function_response,\n            }\n        )  # extend conversation with function response\n        second_response = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo-0613\",\n            messages=messages,\n        )  # get a new response from GPT where it can see the function response\n        return second_response\n\nprint(run_conversation())\n```\n\nHallucinated outputs in function calls can often be mitigated with a system message. For example, if you find that a model is generating function calls with functions that weren't provided to it, try using a system message that says: \"Only use the functions you have been provided with.\"\n\nIn the example above, we sent the function response back to the model and let it decide the next step. It responded with a user-facing message which was telling the user the temperature in Boston, but depending on the query, it may choose to call a function again.\n\nFor example, if you ask the model \u201cFind the weather in Boston this weekend, book dinner for two on Saturday, and update my calendar\u201d and provide the corresponding functions for these queries, it may choose to call them back to back and only at the end create a user-facing message.\n\nIf you want to force the model to call a specific function you can do so by setting `function_call: {\"name\": \"<insert-function-name>\"}`. You can also force the model to generate a user-facing message by setting `function_call: \"none\"`. Note that the default behavior (`function_call: \"auto\"`) is for the model to decide on its own whether to call a function and if so which function to call.\n\nYou can find more examples of function calling in the OpenAI cookbook:\n\n[\n\nFunction calling\n\nLearn from more examples demonstrating function calling\n\n\n\n](https://cookbook.openai.com/examples/how_to_call_functions_with_chat_models)\n\n* * *\n\nThe completions API endpoint received its final update in July 2023 and has a different interface than the new chat completions endpoint. Instead of the input being a list of messages, the input is a freeform text string called a `prompt`.\n\nAn example API call looks as follows:\n\n```\n1\n2\n3\n4\nresponse = openai.Completion.create(\n  model=\"gpt-3.5-turbo-instruct\",\n  prompt=\"Write a tagline for an ice cream shop.\"\n)\n```\n\nSee the full [API reference documentation](https://platform.openai.com/docs/api-reference/completions) to learn more.\n\n[](https://platform.openai.com/docs/guides/gpt/token-log-probabilities)\n\n#### [Token log probabilities](https://platform.openai.com/docs/guides/gpt/token-log-probabilities)\n\nThe completions API can provide a limited number of log probabilities associated with the most likely tokens for each output token. This feature is controlled by using the [logprobs](https://platform.openai.com/docs/api-reference/completions/create#completions/create-logprobs) field. This can be useful in some cases to assess the confidence of the model in its output.\n\n[](https://platform.openai.com/docs/guides/gpt/inserting-text)\n\n#### [Inserting text](https://platform.openai.com/docs/guides/gpt/inserting-text)\n\nThe completions endpoint also supports inserting text by providing a [suffix](https://platform.openai.com/docs/api-reference/completions/create#completions/create-suffix) in addition to the standard prompt which is treated as a prefix. This need naturally arises when writing long-form text, transitioning between paragraphs, following an outline, or guiding the model towards an ending. This also works on code, and can be used to insert in the middle of a function or file.\n\n[](https://platform.openai.com/docs/guides/gpt/completions-response-format)\n\n### [Completions response format](https://platform.openai.com/docs/guides/gpt/completions-response-format)\n\nAn example completions API response looks as follows:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n{\n  \"choices\": [\n    {\n      \"finish_reason\": \"length\",\n      \"index\": 0,\n      \"logprobs\": null,\n      \"text\": \"\\n\\n\\\"Let Your Sweet Tooth Run Wild at Our Creamy Ice Cream Shack\"\n    }\n  ],\n  \"created\": 1683130927,\n  \"id\": \"cmpl-7C9Wxi9Du4j1lQjdjhxBlO22M61LD\",\n  \"model\": \"gpt-3.5-turbo-instruct\",\n  \"object\": \"text_completion\",\n  \"usage\": {\n    \"completion_tokens\": 16,\n    \"prompt_tokens\": 10,\n    \"total_tokens\": 26\n  }\n}\n```\n\nIn Python, the output can be extracted with `response['choices'][0]['text']`.\n\nThe response format is similar to the response format of the Chat completions API but also includes the optional field `logprobs`.\n\n[](https://platform.openai.com/docs/guides/gpt/chat-completions-vs-completions)\n\n## [Chat completions vs. Completions](https://platform.openai.com/docs/guides/gpt/chat-completions-vs-completions)\n\nThe Chat completions format can be made similar to the completions format by constructing a request using a single user message. For example, one can translate from English to French with the following completions prompt:\n\n```\nTranslate the following English text to French: \"{text}\"\n```\n\nAnd an equivalent chat prompt would be:\n\n```\n[{\"role\": \"user\", \"content\": 'Translate the following English text to French: \"{text}\"'}]\n```\n\nLikewise, the completions API can be used to simulate a chat between a user and an assistant by formatting the input [accordingly](https://platform.openai.com/playground/p/default-chat?model=gpt-3.5-turbo-instruct).\n\nThe difference between these APIs derives mainly from the underlying GPT models that are available in each. The chat completions API is the interface to our most capable model (`gpt-4`), and our most cost effective model (`gpt-3.5-turbo`).\n\n[](https://platform.openai.com/docs/guides/gpt/which-model-should-i-use)\n\n#### [Which model should I use?](https://platform.openai.com/docs/guides/gpt/which-model-should-i-use)\n\nWe generally recommend that you use either `gpt-4` or `gpt-3.5-turbo`. Which of these you should use depends on the complexity of the tasks you are using the models for. `gpt-4` generally performs better on a wide range of [evaluations](https://arxiv.org/abs/2303.08774). In particular, `gpt-4` is more capable at carefully following complex instructions. By contrast `gpt-3.5-turbo` is more likely to follow just one part of a complex multi-part instruction. `gpt-4` is less likely than `gpt-3.5-turbo` to make up information, a behavior known as \"hallucination\". `gpt-4` also has a larger context window with a maximum size of 8,192 tokens compared to 4,096 tokens for `gpt-3.5-turbo`. However, `gpt-3.5-turbo` returns outputs with lower latency and costs much less per token.\n\nWe recommend experimenting in the [playground](https://platform.openai.com/playground?mode=chat) to investigate which models provide the best price performance trade-off for your usage. A common design pattern is to use several distinct query types which are each dispatched to the model appropriate to handle them.\n\n[](https://platform.openai.com/docs/guides/gpt/gpt-best-practices)\n\n### [GPT best practices](https://platform.openai.com/docs/guides/gpt/gpt-best-practices)\n\nAn awareness of the best practices for working with GPTs can make a significant difference in application performance. The failure modes that GPTs exhibit and the ways of working around or correcting those failure modes are not always intuitive. There is a skill to working with GPTs which has come to be known as \u201cprompt engineering\u201d, but as the field has progressed its scope has outgrown merely engineering the prompt into engineering systems that use model queries as components. To learn more, read our guide on [GPT best practices](https://platform.openai.com/docs/guides/gpt-best-practices) which covers methods to improve model reasoning, reduce the likelihood of model hallucinations, and more. You can also find many useful resources including code samples in the [OpenAI Cookbook](https://cookbook.openai.com/).\n\n[](https://platform.openai.com/docs/guides/gpt/managing-tokens)\n\n## [Managing tokens](https://platform.openai.com/docs/guides/gpt/managing-tokens)\n\nLanguage models read and write text in chunks called tokens. In English, a token can be as short as one character or as long as one word (e.g., `a` or `apple`), and in some languages tokens can be even shorter than one character or even longer than one word.\n\nFor example, the string `\"ChatGPT is great!\"` is encoded into six tokens: `[\"Chat\", \"G\", \"PT\", \" is\", \" great\", \"!\"]`.\n\nThe total number of tokens in an API call affects:\n\n*   How much your API call costs, as you pay per token\n*   How long your API call takes, as writing more tokens takes more time\n*   Whether your API call works at all, as total tokens must be below the model\u2019s maximum limit (4097 tokens for `gpt-3.5-turbo`)\n\nBoth input and output tokens count toward these quantities. For example, if your API call used 10 tokens in the message input and you received 20 tokens in the message output, you would be billed for 30 tokens. Note however that for some models the price per token is different for tokens in the input vs. the output (see the [pricing](https://openai.com/pricing) page for more information).\n\nTo see how many tokens are used by an API call, check the `usage` field in the API response (e.g., `response['usage']['total_tokens']`).\n\nChat models like `gpt-3.5-turbo` and `gpt-4` use tokens in the same way as the models available in the completions API, but because of their message-based formatting, it's more difficult to count how many tokens will be used by a conversation.\n\nTo see how many tokens are in a text string without making an API call, use OpenAI\u2019s [tiktoken](https://github.com/openai/tiktoken) Python library. Example code can be found in the OpenAI Cookbook\u2019s guide on [how to count tokens with tiktoken](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken).\n\nEach message passed to the API consumes the number of tokens in the content, role, and other fields, plus a few extra for behind-the-scenes formatting. This may change slightly in the future.\n\nIf a conversation has too many tokens to fit within a model\u2019s maximum limit (e.g., more than 4097 tokens for gpt-3.5-turbo), you will have to truncate, omit, or otherwise shrink your text until it fits. Beware that if a message is removed from the messages input, the model will lose all knowledge of it.\n\nNote that very long conversations are more likely to receive incomplete replies. For example, a gpt-3.5-turbo conversation that is 4090 tokens long will have its reply cut off after just 6 tokens.\n\n[](https://platform.openai.com/docs/guides/gpt/parameter-details)\n\n## [Parameter details](https://platform.openai.com/docs/guides/gpt/parameter-details)\n\n**Frequency and presence penalties**\n\nThe frequency and presence penalties found in the [Chat completions API](https://platform.openai.com/docs/api-reference/chat/create) and [Legacy Completions API](https://platform.openai.com/docs/api-reference/completions) can be used to reduce the likelihood of sampling repetitive sequences of tokens. They work by directly modifying the logits (un-normalized log-probabilities) with an additive contribution.\n\n```\nmu[j] -> mu[j] - c[j] * alpha_frequency - float(c[j] > 0) * alpha_presence\n```\n\nWhere:\n\n*   `mu[j]` is the logits of the j-th token\n*   `c[j]` is how often that token was sampled prior to the current position\n*   `float(c[j] > 0)` is 1 if `c[j] > 0` and 0 otherwise\n*   `alpha_frequency` is the frequency penalty coefficient\n*   `alpha_presence` is the presence penalty coefficient\n\nAs we can see, the presence penalty is a one-off additive contribution that applies to all tokens that have been sampled at least once and the frequency penalty is a contribution that is proportional to how often a particular token has already been sampled.\n\nReasonable values for the penalty coefficients are around 0.1 to 1 if the aim is to just reduce repetitive samples somewhat. If the aim is to strongly suppress repetition, then one can increase the coefficients up to 2, but this can noticeably degrade the quality of samples. Negative values can be used to increase the likelihood of repetition.\n\n[](https://platform.openai.com/docs/guides/gpt/faq)\n\n## [FAQ](https://platform.openai.com/docs/guides/gpt/faq)\n\n[](https://platform.openai.com/docs/guides/gpt/why-are-model-outputs-inconsistent)\n\n### [Why are model outputs inconsistent?](https://platform.openai.com/docs/guides/gpt/why-are-model-outputs-inconsistent)\n\nThe API is non-deterministic by default. This means that you might get a slightly different completion every time you call it, even if your prompt stays the same. Setting temperature to 0 will make the outputs mostly deterministic, but a small amount of variability will remain.\n\n[](https://platform.openai.com/docs/guides/gpt/how-should-i-set-the-temperature-parameter)\n\n### [How should I set the temperature parameter?](https://platform.openai.com/docs/guides/gpt/how-should-i-set-the-temperature-parameter)\n\nLower values for temperature result in more consistent outputs, while higher values generate more diverse and creative results. Select a temperature value based on the desired trade-off between coherence and creativity for your specific application.\n\n[](https://platform.openai.com/docs/guides/gpt/is-fine-tuning-available-for-the-latest-models)\n\n### [Is fine-tuning available for the latest models?](https://platform.openai.com/docs/guides/gpt/is-fine-tuning-available-for-the-latest-models)\n\nYes, for some. Currently, you can only fine-tune `gpt-3.5-turbo` and our updated base models (`babbage-002` and `davinci-002`). See the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details on how to use fine-tuned models.\n\n[](https://platform.openai.com/docs/guides/gpt/do-you-store-the-data-that-is-passed-into-the-api)\n\n### [Do you store the data that is passed into the API?](https://platform.openai.com/docs/guides/gpt/do-you-store-the-data-that-is-passed-into-the-api)\n\nAs of March 1st, 2023, we retain your API data for 30 days but no longer use your data sent via the API to improve our models. Learn more in our [data usage policy](https://openai.com/policies/usage-policies). Some endpoints offer [zero retention](https://platform.openai.com/docs/models/default-usage-policies-by-endpoint).\n\n[](https://platform.openai.com/docs/guides/gpt/how-can-i-make-my-application-more-safe)\n\n### [How can I make my application more safe?](https://platform.openai.com/docs/guides/gpt/how-can-i-make-my-application-more-safe)\n\nIf you want to add a moderation layer to the outputs of the Chat API, you can follow our [moderation guide](https://platform.openai.com/docs/guides/moderation) to prevent content that violates OpenAI\u2019s usage policies from being shown.\n\n[](https://platform.openai.com/docs/guides/gpt/should-i-use-chatgpt-or-the-api)\n\n### [Should I use ChatGPT or the API?](https://platform.openai.com/docs/guides/gpt/should-i-use-chatgpt-or-the-api)\n\n[ChatGPT](https://chat.openai.com/) offers a chat interface to the models in the OpenAI API and a range of built-in features such as integrated browsing, code execution, plugins, and more. By contrast, using OpenAI\u2019s API provides more flexibility."
}