{
    "metadata": {
        "type": "web",
        "url": "https://docs.llamaindex.ai/en/stable/core_modules/data_modules/index/document_management.html",
        "title": "Document Management - LlamaIndex \ud83e\udd99 0.8.49",
        "description": null
    },
    "text": "[Back to top](#)\n\nToggle table of contents sidebar\n\n## Document Management[\uf0c1](#document-management \"Permalink to this heading\")\n\nMost LlamaIndex index structures allow for **insertion**, **deletion**, **update**, and **refresh** operations.\n\n## Insertion[\uf0c1](#insertion \"Permalink to this heading\")\n\nYou can \u201cinsert\u201d a new Document into any index data structure, after building the index initially. This document will be broken down into nodes and ingested into the index.\n\nThe underlying mechanism behind insertion depends on the index structure. For instance, for the summary index, a new Document is inserted as additional node(s) in the list. For the vector store index, a new Document (and embeddings) is inserted into the underlying document/embedding store.\n\nAn example notebook showcasing our insert capabilities is given [here](https://github.com/jerryjliu/llama_index/blob/main/examples/paul_graham_essay/InsertDemo.ipynb). In this notebook we showcase how to construct an empty index, manually create Document objects, and add those to our index data structures.\n\nAn example code snippet is given below:\n\nfrom llama\\_index import SummaryIndex, Document\n\nindex \\= SummaryIndex(\\[\\])\ntext\\_chunks \\= \\['text\\_chunk\\_1', 'text\\_chunk\\_2', 'text\\_chunk\\_3'\\]\n\ndoc\\_chunks \\= \\[\\]\nfor i, text in enumerate(text\\_chunks):\n    doc \\= Document(text\\=text, id\\_\\=f\"doc\\_id\\_{i}\")\n    doc\\_chunks.append(doc)\n\n\\# insert\nfor doc\\_chunk in doc\\_chunks:\n    index.insert(doc\\_chunk)\n\n## Deletion[\uf0c1](#deletion \"Permalink to this heading\")\n\nYou can \u201cdelete\u201d a Document from most index data structures by specifying a document\\_id. (**NOTE**: the tree index currently does not support deletion). All nodes corresponding to the document will be deleted.\n\nindex.delete\\_ref\\_doc(\"doc\\_id\\_0\", delete\\_from\\_docstore\\=True)\n\n`delete_from_docstore` will default to `False` in case you are sharing nodes between indexes using the same docstore. However, these nodes will not be used when querying when this is set to `False` as they will be deleted from the `index_struct` of the index, which keeps track of which nodes can be used for querying.\n\n## Update[\uf0c1](#update \"Permalink to this heading\")\n\nIf a Document is already present within an index, you can \u201cupdate\u201d a Document with the same doc `id_` (for instance, if the information in the Document has changed).\n\n\\# NOTE: the document has a \\`doc\\_id\\` specified\ndoc\\_chunks\\[0\\].text \\= \"Brand new document text\"\nindex.update\\_ref\\_doc(\n    doc\\_chunks\\[0\\],\n    update\\_kwargs\\={\"delete\\_kwargs\": {'delete\\_from\\_docstore': True}}\n)\n\nHere, we passed some extra kwargs to ensure the document is deleted from the docstore. This is of course optional.\n\n## Refresh[\uf0c1](#refresh \"Permalink to this heading\")\n\nIf you set the doc `id_` of each document when loading your data, you can also automatically refresh the index.\n\nThe `refresh()` function will only update documents who have the same doc `id_`, but different text contents. Any documents not present in the index at all will also be inserted.\n\n`refresh()` also returns a boolean list, indicating which documents in the input have been refreshed in the index.\n\n\\# modify first document, with the same doc\\_id\ndoc\\_chunks\\[0\\] \\= Document(text\\='Super new document text', id\\_\\=\"doc\\_id\\_0\")\n\n\\# add a new document\ndoc\\_chunks.append(Document(text\\=\"This isn't in the index yet, but it will be soon!\", id\\_\\=\"doc\\_id\\_3\"))\n\n\\# refresh the index\nrefreshed\\_docs \\= index.refresh\\_ref\\_docs(\n    doc\\_chunks,\n    update\\_kwargs\\={\"delete\\_kwargs\": {'delete\\_from\\_docstore': True}}\n)\n\n\\# refreshed\\_docs\\[0\\] and refreshed\\_docs\\[-1\\] should be true\n\nAgain, we passed some extra kwargs to ensure the document is deleted from the docstore. This is of course optional.\n\nIf you `print()` the output of `refresh()`, you would see which input documents were refreshed:\n\nprint(refreshed\\_docs)\n\\> \\[True, False, False, True\\]\n\nThis is most useful when you are reading from a directory that is constantly updating with new information.\n\nTo automatically set the doc `id_` when using the `SimpleDirectoryReader`, you can set the `filename_as_id` flag. More details can be found [here](https://docs.llamaindex.ai/en/stable/core_modules/data_modules/documents_and_nodes/usage_documents.html).\n\n## Document Tracking[\uf0c1](#document-tracking \"Permalink to this heading\")\n\nAny index that uses the docstore (i.e. all indexes except for most vector store integrations), you can also see which documents you have inserted into the docstore.\n\nprint(index.ref\\_doc\\_info)\n\\> {'doc\\_id\\_1': RefDocInfo(node\\_ids\\=\\['071a66a8-3c47-49ad-84fa-7010c6277479'\\], metadata\\={}),\n   'doc\\_id\\_2': RefDocInfo(node\\_ids\\=\\['9563e84b-f934-41c3-acfd-22e88492c869'\\], metadata\\={}),\n   'doc\\_id\\_0': RefDocInfo(node\\_ids\\=\\['b53e6c2f-16f7-4024-af4c-42890e945f36'\\], metadata\\={}),\n   'doc\\_id\\_3': RefDocInfo(node\\_ids\\=\\['6bedb29f-15db-4c7c-9885-7490e10aa33f'\\], metadata\\={})}\n\nEach entry in the output shows the ingested doc `id_`s as keys, and their associated `node_ids` of the nodes they were split into.\n\nLastly, the original `metadata` dictionary of each input document is also tracked. You can read more about the `metadata` attribute in [Customizing Documents](https://docs.llamaindex.ai/en/stable/core_modules/data_modules/documents_and_nodes/usage_documents.html)."
}