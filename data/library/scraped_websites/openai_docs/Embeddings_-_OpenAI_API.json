{
    "metadata": {
        "type": "web",
        "url": "https://platform.openai.com/docs/guides/embeddings/how-can-i-retrieve-k-nearest-embedding-vectors-quickly",
        "title": "Embeddings - OpenAI API",
        "description": "Explore resources, tutorials, API docs, and dynamic examples to get the most out of OpenAI's developer platform."
    },
    "text": "[](https://platform.openai.com/docs/guides/embeddings/embeddings)\n\n## [Embeddings](https://platform.openai.com/docs/guides/embeddings/embeddings)\n\n[](https://platform.openai.com/docs/guides/embeddings/what-are-embeddings)\n\n## [What are embeddings?](https://platform.openai.com/docs/guides/embeddings/what-are-embeddings)\n\nOpenAI\u2019s text embeddings measure the relatedness of text strings. Embeddings are commonly used for:\n\n*   **Search** (where results are ranked by relevance to a query string)\n*   **Clustering** (where text strings are grouped by similarity)\n*   **Recommendations** (where items with related text strings are recommended)\n*   **Anomaly detection** (where outliers with little relatedness are identified)\n*   **Diversity measurement** (where similarity distributions are analyzed)\n*   **Classification** (where text strings are classified by their most similar label)\n\nAn embedding is a vector (list) of floating point numbers. The [distance](https://platform.openai.com/docs/guides/embeddings/which-distance-function-should-i-use) between two vectors measures their relatedness. Small distances suggest high relatedness and large distances suggest low relatedness.\n\nVisit our [pricing page](https://openai.com/api/pricing/) to learn about Embeddings pricing. Requests are billed based on the number of [tokens](https://platform.openai.com/tokenizer) in the [input](https://platform.openai.com/docs/api-reference/embeddings/create#embeddings/create-input) sent.\n\n**To see embeddings in action, check out our code samples**\n\n*   Classification\n*   Topic clustering\n*   Search\n*   Recommendations\n\n[Browse Samples\u200d](https://platform.openai.com/docs/guides/embeddings/use-cases)\n\n[](https://platform.openai.com/docs/guides/embeddings/how-to-get-embeddings)\n\n## [How to get embeddings](https://platform.openai.com/docs/guides/embeddings/how-to-get-embeddings)\n\nTo get an embedding, send your text string to the [embeddings API endpoint](https://platform.openai.com/docs/api-reference/embeddings) along with a choice of embedding model ID (e.g., `text-embedding-ada-002`). The response will contain an embedding, which you can extract, save, and use.\n\nExample requests:\n\n```\n1\n2\n3\n4\n5\n6\n7\ncurl https://api.openai.com/v1/embeddings \\\n  -H \"Content-Type: application/json\" \\\n  -H \"Authorization: Bearer $OPENAI_API_KEY\" \\\n  -d '{\n    \"input\": \"Your text string goes here\",\n    \"model\": \"text-embedding-ada-002\"\n  }'\n```\n\nExample response:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n{\n  \"data\": [\n    {\n      \"embedding\": [\n        -0.006929283495992422,\n        -0.005336422007530928,\n        ...\n        -4.547132266452536e-05,\n        -0.024047505110502243\n      ],\n      \"index\": 0,\n      \"object\": \"embedding\"\n    }\n  ],\n  \"model\": \"text-embedding-ada-002\",\n  \"object\": \"list\",\n  \"usage\": {\n    \"prompt_tokens\": 5,\n    \"total_tokens\": 5\n  }\n}\n```\n\nSee more Python code examples in the [OpenAI Cookbook](https://cookbook.openai.com/).\n\nWhen using OpenAI embeddings, please keep in mind their [limitations and risks](https://platform.openai.com/docs/guides/embeddings/limitations-risks).\n\n[](https://platform.openai.com/docs/guides/embeddings/embedding-models)\n\n## [Embedding models](https://platform.openai.com/docs/guides/embeddings/embedding-models)\n\nOpenAI offers one second-generation embedding model (denoted by `-002` in the model ID) and 16 first-generation models (denoted by `-001` in the model ID).\n\nWe recommend using text-embedding-ada-002 for nearly all use cases. It\u2019s better, cheaper, and simpler to use. Read the [blog post announcement](https://openai.com/blog/new-and-improved-embedding-model).\n\n| Model generation | tokenizer | max input tokens | knowledge cutoff |\n| --- | --- | --- | --- |\n| V2  | cl100k\\_base | 8191 | Sep 2021 |\n| V1  | GPT-2/GPT-3 | 2046 | Aug 2020 |\n\nUsage is priced per input token, at a rate of $0.0004 per 1000 tokens, or about ~3,000 pages per US dollar (assuming ~800 tokens per page):\n\n| Model | Rough pages per dollar | Example performance on [BEIR](https://paperswithcode.com/sota/zero-shot-text-search-on-beir) search eval |\n| --- | --- | --- |\n| text-embedding-ada-002 | 3000 | 53.9 |\n| \\*-davinci-\\*-001 | 6   | 52.8 |\n| \\*-curie-\\*-001 | 60  | 50.9 |\n| \\*-babbage-\\*-001 | 240 | 50.4 |\n| \\*-ada-\\*-001 | 300 | 49.0 |\n\n[](https://platform.openai.com/docs/guides/embeddings/second-generation-models)\n\n### [Second-generation models](https://platform.openai.com/docs/guides/embeddings/second-generation-models)\n\n| Model name | tokenizer | max input tokens | output dimensions |\n| --- | --- | --- | --- |\n| text-embedding-ada-002 | cl100k\\_base | 8191 | 1536 |\n\nFirst-generation models (not recommended)\n\nAll first-generation models (those ending in -001) use the [GPT-3 tokenizer](https://platform.openai.com/tokenizer) and have a max input of 2046 tokens.\n\nFirst-generation embeddings are generated by five different model families tuned for three different tasks: text search, text similarity and code search. The search models come in pairs: one for short queries and one for long documents. Each family includes up to four models on a spectrum of quality and speed:\n\n| Model | output dimensions |\n| --- | --- |\n| Ada | 1024 |\n| Babbage | 2048 |\n| Curie | 4096 |\n| Davinci | 12288 |\n\nDavinci is the most capable, but is slower and more expensive than the other models. Ada is the least capable, but is significantly faster and cheaper.\n\n[](https://platform.openai.com/docs/guides/embeddings/similarity-embeddings)\n\n### [Similarity embeddings](https://platform.openai.com/docs/guides/embeddings/similarity-embeddings)\n\nSimilarity models are best at capturing semantic similarity between pieces of text.\n\n| Use cases | Available models |\n| --- | --- |\n| Clustering, regression, anomaly detection, visualization | `text-similarity-ada-001`  <br>`text-similarity-babbage-001`  <br>`text-similarity-curie-001`  <br>`text-similarity-davinci-001` |\n\n[](https://platform.openai.com/docs/guides/embeddings/text-search-embeddings)\n\n### [Text search embeddings](https://platform.openai.com/docs/guides/embeddings/text-search-embeddings)\n\nText search models help measure which long documents are most relevant to a short search query. Two models are used: one for embedding the search query and one for embedding the documents to be ranked. The document embeddings closest to the query embedding should be the most relevant.\n\n| Use cases | Available models |\n| --- | --- |\n| Search, context relevance, information retrieval | `text-search-ada-doc-001`  <br>`text-search-ada-query-001`  <br>`text-search-babbage-doc-001`  <br>`text-search-babbage-query-001`  <br>`text-search-curie-doc-001`  <br>`text-search-curie-query-001`  <br>`text-search-davinci-doc-001`  <br>`text-search-davinci-query-001` |\n\n[](https://platform.openai.com/docs/guides/embeddings/code-search-embeddings)\n\n### [Code search embeddings](https://platform.openai.com/docs/guides/embeddings/code-search-embeddings)\n\nSimilarly to search embeddings, there are two types: one for embedding natural language search queries and one for embedding code snippets to be retrieved.\n\n| Use cases | Available models |\n| --- | --- |\n| Code search and relevance | `code-search-ada-code-001`  <br>`code-search-ada-text-001`  <br>`code-search-babbage-code-001`  <br>`code-search-babbage-text-001` |\n\nWith the `-001` text embeddings (not `-002`, and not code embeddings), we suggest replacing newlines (`\\n`) in your input with a single space, as we have seen worse results when newlines are present.\n\n[](https://platform.openai.com/docs/guides/embeddings/use-cases)\n\n## [Use cases](https://platform.openai.com/docs/guides/embeddings/use-cases)\n\nHere we show some representative use cases. We will use the [Amazon fine-food reviews dataset](https://www.kaggle.com/snap/amazon-fine-food-reviews) for the following examples.\n\n[](https://platform.openai.com/docs/guides/embeddings/obtaining-the-embeddings)\n\n### [Obtaining the embeddings](https://platform.openai.com/docs/guides/embeddings/obtaining-the-embeddings)\n\nThe dataset contains a total of 568,454 food reviews Amazon users left up to October 2012. We will use a subset of 1,000 most recent reviews for illustration purposes. The reviews are in English and tend to be positive or negative. Each review has a ProductId, UserId, Score, review title (Summary) and review body (Text). For example:\n\n| Product Id | User Id | Score | Summary | Text |\n| --- | --- | --- | --- | --- |\n| B001E4KFG0 | A3SGXH7AUHU8GW | 5   | Good Quality Dog Food | I have bought several of the Vitality canned... |\n| B00813GRG4 | A1D87F6ZCVE5NK | 1   | Not as Advertised | Product arrived labeled as Jumbo Salted Peanut... |\n\nWe will combine the review summary and review text into a single combined text. The model will encode this combined text and output a single vector embedding.\n\n[Get embeddings from dataset](https://cookbook.openai.com/examples/get_embeddings_from_dataset)\n\n```\n1\n2\n3\n4\n5\n6\ndef get_embedding(text, model=\"text-embedding-ada-002\"):\n   text = text.replace(\"\\n\", \" \")\n   return openai.Embedding.create(input = [text], model=model)['data'][0]['embedding']\n\ndf['ada_embedding'] = df.combined.apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\ndf.to_csv('output/embedded_1k_reviews.csv', index=False)\n```\n\nTo load the data from a saved file, you can run the following:\n\n```\n1\n2\n3\n4\nimport pandas as pd\n\ndf = pd.read_csv('output/embedded_1k_reviews.csv')\ndf['ada_embedding'] = df.ada_embedding.apply(eval).apply(np.array)\n```\n\n[Visualizing\\_embeddings\\_in\\_2D.ipynb](https://cookbook.openai.com/examples/visualizing_embeddings_in_2d)\n\nThe size of the embeddings varies with the complexity of the underlying model. In order to visualize this high dimensional data we use the t-SNE algorithm to transform the data into two dimensions.\n\nWe color the individual reviews based on the star rating which the reviewer has given:\n\n*   1-star: red\n*   2-star: dark orange\n*   3-star: gold\n*   4-star: turquoise\n*   5-star: dark green\n\n![Amazon ratings visualized in language using t-SNE](https://cdn.openai.com/API/docs/images/embeddings-tsne.png)\n\nThe visualization seems to have produced roughly 3 clusters, one of which has mostly negative reviews.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\nimport pandas as pd\nfrom sklearn.manifold import TSNE\nimport matplotlib.pyplot as plt\nimport matplotlib\n\ndf = pd.read_csv('output/embedded_1k_reviews.csv')\nmatrix = df.ada_embedding.apply(eval).to_list()\n\n# Create a t-SNE model and transform the data\ntsne = TSNE(n_components=2, perplexity=15, random_state=42, init='random', learning_rate=200)\nvis_dims = tsne.fit_transform(matrix)\n\ncolors = [\"red\", \"darkorange\", \"gold\", \"turquiose\", \"darkgreen\"]\nx = [x for x,y in vis_dims]\ny = [y for x,y in vis_dims]\ncolor_indices = df.Score.values - 1\n\ncolormap = matplotlib.colors.ListedColormap(colors)\nplt.scatter(x, y, c=color_indices, cmap=colormap, alpha=0.3)\nplt.title(\"Amazon ratings visualized in language using t-SNE\")\n```\n\nEmbedding as a text feature encoder for ML algorithms\n\n[Regression\\_using\\_embeddings.ipynb](https://cookbook.openai.com/examples/regression_using_embeddings)\n\nAn embedding can be used as a general free-text feature encoder within a machine learning model. Incorporating embeddings will improve the performance of any machine learning model, if some of the relevant inputs are free text. An embedding can also be used as a categorical feature encoder within a ML model. This adds most value if the names of categorical variables are meaningful and numerous, such as job titles. Similarity embeddings generally perform better than search embeddings for this task.\n\nWe observed that generally the embedding representation is very rich and information dense. For example, reducing the dimensionality of the inputs using SVD or PCA, even by 10%, generally results in worse downstream performance on specific tasks.\n\nThis code splits the data into a training set and a testing set, which will be used by the following two use cases, namely regression and classification.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(\n    list(df.ada_embedding.values),\n    df.Score,\n    test_size = 0.2,\n    random_state=42\n)\n```\n\n[](https://platform.openai.com/docs/guides/embeddings/regression-using-the-embedding-features)\n\n#### [Regression using the embedding features](https://platform.openai.com/docs/guides/embeddings/regression-using-the-embedding-features)\n\nEmbeddings present an elegant way of predicting a numerical value. In this example we predict the reviewer\u2019s star rating, based on the text of their review. Because the semantic information contained within embeddings is high, the prediction is decent even with very few reviews.\n\nWe assume the score is a continuous variable between 1 and 5, and allow the algorithm to predict any floating point value. The ML algorithm minimizes the distance of the predicted value to the true score, and achieves a mean absolute error of 0.39, which means that on average the prediction is off by less than half a star.\n\n```\n1\n2\n3\n4\n5\nfrom sklearn.ensemble import RandomForestRegressor\n\nrfr = RandomForestRegressor(n_estimators=100)\nrfr.fit(X_train, y_train)\npreds = rfr.predict(X_test)\n```\n\nClassification using the embedding features\n\n[Classification\\_using\\_embeddings.ipynb](https://cookbook.openai.com/examples/classification_using_embeddings)\n\nThis time, instead of having the algorithm predict a value anywhere between 1 and 5, we will attempt to classify the exact number of stars for a review into 5 buckets, ranging from 1 to 5 stars.\n\nAfter the training, the model learns to predict 1 and 5-star reviews much better than the more nuanced reviews (2-4 stars), likely due to more extreme sentiment expression.\n\n```\n1\n2\n3\n4\n5\n6\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report, accuracy_score\n\nclf = RandomForestClassifier(n_estimators=100)\nclf.fit(X_train, y_train)\npreds = clf.predict(X_test)\n```\n\n[Zero-shot\\_classification\\_with\\_embeddings.ipynb](https://cookbook.openai.com/examples/zero-shot_classification_with_embeddings)\n\nWe can use embeddings for zero shot classification without any labeled training data. For each class, we embed the class name or a short description of the class. To classify some new text in a zero-shot manner, we compare its embedding to all class embeddings and predict the class with the highest similarity.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\nfrom openai.embeddings_utils import cosine_similarity, get_embedding\n\ndf= df[df.Score!=3]\ndf['sentiment'] = df.Score.replace({1:'negative', 2:'negative', 4:'positive', 5:'positive'})\n\nlabels = ['negative', 'positive']\nlabel_embeddings = [get_embedding(label, model=model) for label in labels]\n\ndef label_score(review_embedding, label_embeddings):\n   return cosine_similarity(review_embedding, label_embeddings[1]) - cosine_similarity(review_embedding, label_embeddings[0])\n\nprediction = 'positive' if label_score('Sample Review', label_embeddings) > 0 else 'negative'\n```\n\nObtaining user and product embeddings for cold-start recommendation\n\n[User\\_and\\_product\\_embeddings.ipynb](https://cookbook.openai.com/examples/user_and_product_embeddings)\n\nWe can obtain a user embedding by averaging over all of their reviews. Similarly, we can obtain a product embedding by averaging over all the reviews about that product. In order to showcase the usefulness of this approach we use a subset of 50k reviews to cover more reviews per user and per product.\n\nWe evaluate the usefulness of these embeddings on a separate test set, where we plot similarity of the user and product embedding as a function of the rating. Interestingly, based on this approach, even before the user receives the product we can predict better than random whether they would like the product.\n\n![Boxplot grouped by Score](https://cdn.openai.com/API/docs/images/embeddings-boxplot.png)\n\n```\nuser_embeddings = df.groupby('UserId').ada_embedding.apply(np.mean)\nprod_embeddings = df.groupby('ProductId').ada_embedding.apply(np.mean)\n```\n\n[Clustering.ipynb](https://cookbook.openai.com/examples/clustering)\n\nClustering is one way of making sense of a large volume of textual data. Embeddings are useful for this task, as they provide semantically meaningful vector representations of each text. Thus, in an unsupervised way, clustering will uncover hidden groupings in our dataset.\n\nIn this example, we discover four distinct clusters: one focusing on dog food, one on negative reviews, and two on positive reviews.\n\n![Clusters identified visualized in language 2d using t-SNE](https://cdn.openai.com/API/docs/images/embeddings-cluster.png)\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport numpy as np\nfrom sklearn.cluster import KMeans\n\nmatrix = np.vstack(df.ada_embedding.values)\nn_clusters = 4\n\nkmeans = KMeans(n_clusters = n_clusters, init='k-means++', random_state=42)\nkmeans.fit(matrix)\ndf['Cluster'] = kmeans.labels_\n```\n\nText search using embeddings\n\n[Semantic\\_text\\_search\\_using\\_embeddings.ipynb](https://cookbook.openai.com/examples/semantic_text_search_using_embeddings)\n\nTo retrieve the most relevant documents we use the cosine similarity between the embedding vectors of the query and each document, and return the highest scored documents.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\nfrom openai.embeddings_utils import get_embedding, cosine_similarity\n\ndef search_reviews(df, product_description, n=3, pprint=True):\n   embedding = get_embedding(product_description, model='text-embedding-ada-002')\n   df['similarities'] = df.ada_embedding.apply(lambda x: cosine_similarity(x, embedding))\n   res = df.sort_values('similarities', ascending=False).head(n)\n   return res\n\nres = search_reviews(df, 'delicious beans', n=3)\n```\n\nCode search using embeddings\n\n[Code\\_search.ipynb](https://cookbook.openai.com/examples/code_search)\n\nCode search works similarly to embedding-based text search. We provide a method to extract Python functions from all the Python files in a given repository. Each function is then indexed by the `text-embedding-ada-002` model.\n\nTo perform a code search, we embed the query in natural language using the same model. Then we calculate cosine similarity between the resulting query embedding and each of the function embeddings. The highest cosine similarity results are most relevant.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nfrom openai.embeddings_utils import get_embedding, cosine_similarity\n\ndf['code_embedding'] = df['code'].apply(lambda x: get_embedding(x, model='text-embedding-ada-002'))\n\ndef search_functions(df, code_query, n=3, pprint=True, n_lines=7):\n   embedding = get_embedding(code_query, model='text-embedding-ada-002')\n   df['similarities'] = df.code_embedding.apply(lambda x: cosine_similarity(x, embedding))\n\n   res = df.sort_values('similarities', ascending=False).head(n)\n   return res\nres = search_functions(df, 'Completions API tests', n=3)\n```\n\nRecommendations using embeddings\n\n[Recommendation\\_using\\_embeddings.ipynb](https://cookbook.openai.com/examples/recommendation_using_embeddings)\n\nBecause shorter distances between embedding vectors represent greater similarity, embeddings can be useful for recommendation.\n\nBelow, we illustrate a basic recommender. It takes in a list of strings and one 'source' string, computes their embeddings, and then returns a ranking of the strings, ranked from most similar to least similar. As a concrete example, the linked notebook below applies a version of this function to the [AG news dataset](http://groups.di.unipi.it/~gulli/AG_corpus_of_news_articles.html) (sampled down to 2,000 news article descriptions) to return the top 5 most similar articles to any given source article.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\ndef recommendations_from_strings(\n   strings: List[str],\n   index_of_source_string: int,\n   model=\"text-embedding-ada-002\",\n) -> List[int]:\n   \"\"\"Return nearest neighbors of a given string.\"\"\"\n\n   # get embeddings for all strings\n   embeddings = [embedding_from_string(string, model=model) for string in strings]\n\n   # get the embedding of the source string\n   query_embedding = embeddings[index_of_source_string]\n\n   # get distances between the source embedding and other embeddings (function from embeddings_utils.py)\n   distances = distances_from_embeddings(query_embedding, embeddings, distance_metric=\"cosine\")\n\n   # get indices of nearest neighbors (function from embeddings_utils.py)\n   indices_of_nearest_neighbors = indices_of_nearest_neighbors_from_distances(distances)\n   return indices_of_nearest_neighbors\n```\n\n[](https://platform.openai.com/docs/guides/embeddings/limitations-risks)\n\n## [Limitations & risks](https://platform.openai.com/docs/guides/embeddings/limitations-risks)\n\nOur embedding models may be unreliable or pose social risks in certain cases, and may cause harm in the absence of mitigations.\n\n[](https://platform.openai.com/docs/guides/embeddings/social-bias)\n\n#### [Social bias](https://platform.openai.com/docs/guides/embeddings/social-bias)\n\n> **Limitation**: The models encode social biases, e.g. via stereotypes or negative sentiment towards certain groups.\n\nWe found evidence of bias in our models via running the SEAT ([May et al, 2019](https://arxiv.org/abs/1903.10561)) and the Winogender ([Rudinger et al, 2018](https://arxiv.org/abs/1804.09301)) benchmarks. Together, these benchmarks consist of 7 tests that measure whether models contain implicit biases when applied to gendered names, regional names, and some stereotypes.\n\nFor example, we found that our models more strongly associate (a) European American names with positive sentiment, when compared to African American names, and (b) negative stereotypes with black women.\n\nThese benchmarks are limited in several ways: (a) they may not generalize to your particular use case, and (b) they only test for a very small slice of possible social bias.\n\n**These tests are preliminary, and we recommend running tests for your specific use cases.** These results should be taken as evidence of the existence of the phenomenon, not a definitive characterization of it for your use case. Please see our [usage policies](https://openai.com/policies/usage-policies) for more details and guidance.\n\nPlease [contact our support team via chat](https://help.openai.com/en/) if you have any questions; we are happy to advise on this.\n\n[](https://platform.openai.com/docs/guides/embeddings/blindness-to-recent-events)\n\n#### [Blindness to recent events](https://platform.openai.com/docs/guides/embeddings/blindness-to-recent-events)\n\n> **Limitation**: Models lack knowledge of events that occurred after August 2020.\n\nOur models are trained on datasets that contain some information about real world events up until 8/2020. If you rely on the models representing recent events, then they may not perform well.\n\n[](https://platform.openai.com/docs/guides/embeddings/frequently-asked-questions)\n\n## [Frequently asked questions](https://platform.openai.com/docs/guides/embeddings/frequently-asked-questions)\n\n[](https://platform.openai.com/docs/guides/embeddings/how-can-i-tell-how-many-tokens-a-string-has-before-i-embed-it)\n\n### [How can I tell how many tokens a string has before I embed it?](https://platform.openai.com/docs/guides/embeddings/how-can-i-tell-how-many-tokens-a-string-has-before-i-embed-it)\n\nIn Python, you can split a string into tokens with OpenAI's tokenizer [`tiktoken`](https://github.com/openai/tiktoken).\n\nExample code:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\nimport tiktoken\n\ndef num_tokens_from_string(string: str, encoding_name: str) -> int:\n    \"\"\"Returns the number of tokens in a text string.\"\"\"\n    encoding = tiktoken.get_encoding(encoding_name)\n    num_tokens = len(encoding.encode(string))\n    return num_tokens\n\nnum_tokens_from_string(\"tiktoken is great!\", \"cl100k_base\")\n```\n\nFor second-generation embedding models like `text-embedding-ada-002`, use the `cl100k_base` encoding.\n\nMore details and example code are in the OpenAI Cookbook guide [how to count tokens with tiktoken](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken).\n\n[](https://platform.openai.com/docs/guides/embeddings/how-can-i-retrieve-k-nearest-embedding-vectors-quickly)\n\n### [How can I retrieve K nearest embedding vectors quickly?](https://platform.openai.com/docs/guides/embeddings/how-can-i-retrieve-k-nearest-embedding-vectors-quickly)\n\nFor searching over many vectors quickly, we recommend using a vector database. You can find examples of working with vector databases and the OpenAI API [in our Cookbook](https://cookbook.openai.com/examples/vector_databases/readme) on GitHub.\n\nVector database options include:\n\n*   [Chroma](https://cookbook.openai.com/examples/vector_databases/chroma/using_chroma_for_embeddings_search), an open-source embeddings store\n*   [Elasticsearch](https://cookbook.openai.com/examples/vector_databases/elasticsearch/readme), a popular search/analytics engine and vector database\n*   [Milvus](https://cookbook.openai.com/examples/vector_databases/milvus/getting_started_with_milvus_and_openai), a vector database built for scalable similarity search\n*   [Pinecone](https://cookbook.openai.com/examples/vector_databases/pinecone/readme), a fully managed vector database\n*   [Qdrant](https://cookbook.openai.com/examples/vector_databases/qdrant/getting_started_with_qdrant_and_openai), a vector search engine\n*   [Redis](https://cookbook.openai.com/examples/vector_databases/redis/readme) as a vector database\n*   [Typesense](https://cookbook.openai.com/examples/vector_databases/typesense/readme), fast open source vector search\n*   [Weaviate](https://cookbook.openai.com/examples/vector_databases/weaviate/readme), an open-source vector search engine\n*   [Zilliz](https://cookbook.openai.com/examples/vector_databases/zilliz/getting_started_with_zilliz_and_openai), data infrastructure, powered by Milvus\n\n[](https://platform.openai.com/docs/guides/embeddings/which-distance-function-should-i-use)\n\n### [Which distance function should I use?](https://platform.openai.com/docs/guides/embeddings/which-distance-function-should-i-use)\n\nWe recommend [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity). The choice of distance function typically doesn\u2019t matter much.\n\nOpenAI embeddings are normalized to length 1, which means that:\n\n*   Cosine similarity can be computed slightly faster using just a dot product\n*   Cosine similarity and Euclidean distance will result in the identical rankings\n\n[](https://platform.openai.com/docs/guides/embeddings/can-i-share-my-embeddings-online)\n\n### [Can I share my embeddings online?](https://platform.openai.com/docs/guides/embeddings/can-i-share-my-embeddings-online)\n\nCustomers own their input and output from our models, including in the case of embeddings. You are responsible for ensuring that the content you input to our API does not violate any applicable law or our [Terms of Use](https://openai.com/policies/terms-of-use)."
}