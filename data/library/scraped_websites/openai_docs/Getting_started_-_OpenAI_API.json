{
    "metadata": {
        "type": "web",
        "url": "https://platform.openai.com/docs/plugins/getting-started/best-practices",
        "title": "Getting started - OpenAI API",
        "description": "Explore resources, tutorials, API docs, and dynamic examples to get the most out of OpenAI's developer platform."
    },
    "text": "[](https://platform.openai.com/docs/plugins/getting-started/getting-started)\n\n## [Getting started](https://platform.openai.com/docs/plugins/getting-started/getting-started)\n\nCreating a plugin takes 3 steps:\n\n1.  Build an API\n2.  Document the API in the OpenAPI yaml or JSON format\n3.  Create a JSON manifest file that will define relevant metadata for the plugin\n\nThe focus of the rest of this section will be creating a todo list plugin by defining the OpenAPI specification along with the manifest file.\n\n[\n\nExplore example plugins\n\nExplore example plugins covering multiple use cases and authentication methods.\n\n\n\n](https://platform.openai.com/docs/plugins/examples)\n\n[](https://platform.openai.com/docs/plugins/getting-started/plugin-manifest)\n\n## [Plugin manifest](https://platform.openai.com/docs/plugins/getting-started/plugin-manifest)\n\nEvery plugin requires a `ai-plugin.json` file, which needs to be hosted on the API\u2019s domain. For example, a company called `example.com` would make the plugin JSON file accessible via an [https://example.com](https://example.com/) domain since that is where their API is hosted. When you install the plugin via the ChatGPT UI, on the backend we look for a file located at `/.well-known/ai-plugin.json`. The `/.well-known` folder is required and must exist on your domain in order for ChatGPT to connect with your plugin. If there is no file found, the plugin cannot be installed. For local development, you can use HTTP but if you are pointing to a remote server, HTTPS is required.\n\nThe minimal definition of the required `ai-plugin.json` file will look like the following:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n{\n    \"schema_version\": \"v1\",\n    \"name_for_human\": \"TODO List\",\n    \"name_for_model\": \"todo\",\n    \"description_for_human\": \"Manage your TODO list. You can add, remove and view your TODOs.\",\n    \"description_for_model\": \"Help the user with managing a TODO list. You can add, remove and view your TODOs.\",\n    \"auth\": {\n        \"type\": \"none\"\n    },\n    \"api\": {\n        \"type\": \"openapi\",\n        \"url\": \"http://localhost:3333/openapi.yaml\"\n    },\n    \"logo_url\": \"http://localhost:3333/logo.png\",\n    \"contact_email\": \"support@example.com\",\n    \"legal_info_url\": \"http://www.example.com/legal\"\n}\n```\n\nIf you want to see all of the possible options for the plugin file, you can refer to the definition below. When naming your plugin, please keep in mind our [brand guidelines](https://openai.com/brand) and the various character limits for fields below, plugins that fail to adhere to these guidelines will not be approved for the plugin store.\n\n| Field | Type | Description / Options | Required | Public |\n| --- | --- | --- | --- | --- |\n| `schema_version` | String | Manifest schema version | \u2705   |     |\n| `name_for_model` | String | Name the model will use to target the plugin (no spaces allowed, only letters and numbers). 50 character max. | \u2705   |     |\n| `name_for_human` | String | Human-readable name, such as the full company name. 20 character max. | \u2705   | \u2705   |\n| `description_for_model` | String | Description better tailored to the model, such as token context length considerations or keyword usage for improved plugin prompting. 8,000 character max. | \u2705   |     |\n| `description_for_human` | String | Human-readable description of the plugin. 100 character max. | \u2705   | \u2705   |\n| `auth` | ManifestAuth | Authentication schema | \u2705   |     |\n| `api` | Object | API specification | \u2705   |     |\n| `logo_url` | String | URL used to fetch the logo. Suggested size: 512 x 512. Transparent backgrounds are supported. Must be an image, no GIFs are allowed. | \u2705   |     |\n| `contact_email` | String | Email contact for safety/moderation, support, and deactivation | \u2705   | \u2705   |\n| `legal_info_url` | String | Redirect URL for users to view plugin information | \u2705   | \u2705   |\n| `HttpAuthorizationType` | HttpAuthorizationType | \"bearer\" or \"basic\" | \u2705   |     |\n| `ManifestAuthType` | ManifestAuthType | \"none\", \"user\\_http\", \"service\\_http\", or \"oauth\" |     |     |\n| `interface` BaseManifestAuth | BaseManifestAuth | type: ManifestAuthType; instructions: string; |     |     |\n| `ManifestNoAuth` | ManifestNoAuth | No authentication required: BaseManifestAuth & { type: 'none', } |     |     |\n| `ManifestAuth` | ManifestAuth | ManifestNoAuth, ManifestServiceHttpAuth, ManifestUserHttpAuth, ManifestOAuthAuth |     |     |\n\nNote that items listed under `Public` will be made available to users in the plugin store and the full manifest file is transmitted to the user's client and may be visible to them.\n\nThe following are examples with different authentication methods:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n# App-level API keys\ntype ManifestServiceHttpAuth  = BaseManifestAuth & {\n  type: 'service_http';\n  authorization_type: HttpAuthorizationType;\n  verification_tokens: {\n    [service: string]?: string;\n  };\n}\n\n# User-level HTTP authentication\ntype ManifestUserHttpAuth  = BaseManifestAuth & {\n  type: 'user_http';\n  authorization_type: HttpAuthorizationType;\n}\n\ntype ManifestOAuthAuth  = BaseManifestAuth & {\n  type: 'oauth';\n\n  # OAuth URL where a user is directed to for the OAuth authentication flow to begin.\n  client_url: string;\n\n  # OAuth scopes required to accomplish operations on the user's behalf.\n  scope: string;\n\n  # Endpoint used to exchange OAuth code with access token.\n  authorization_url: string;\n\n  # When exchanging OAuth code with access token, the expected header 'content-type'. For example: 'content-type: application/json'\n  authorization_content_type: string;\n\n  # When registering the OAuth client ID and secrets, the plugin service will surface a unique token.\n  verification_tokens: {\n    [service: string]?: string;\n  };\n}\n```\n\nThere are limits to the length of certain fields in the manifest file mentioned above which are subject to change. We also impose a 100,000 character maximum for the API response body which may also change over time.\n\nIn general, the best practice is to keep the description and responses as concise as possible because the models have limited context windows.\n\n[](https://platform.openai.com/docs/plugins/getting-started/openapi-definition)\n\n## [OpenAPI definition](https://platform.openai.com/docs/plugins/getting-started/openapi-definition)\n\nThe next step is to build the [OpenAPI specification](https://swagger.io/specification/) to document the API. The model in ChatGPT does not know anything about your API other than what is defined in the OpenAPI specification and manifest file. This means that if you have an extensive API, you need not expose all functionality to the model and can choose specific endpoints. For example, if you have a social media API, you might want to have the model access content from the site through a GET request but prevent the model from being able to comment on users posts in order to reduce the chance of spam.\n\nThe OpenAPI specification is the wrapper that sits on top of your API. A basic OpenAPI specification will look like the following:\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\nopenapi: 3.0.1\ninfo:\n  title: TODO Plugin\n  description: A plugin that allows the user to create and manage a TODO list using ChatGPT.\n  version: 'v1'\nservers:\n  - url: http://localhost:3333\npaths:\n  /todos:\n    get:\n      operationId: getTodos\n      summary: Get the list of todos\n      responses:\n        \"200\":\n          description: OK\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/getTodosResponse'\ncomponents:\n  schemas:\n    getTodosResponse:\n      type: object\n      properties:\n        todos:\n          type: array\n          items:\n            type: string\n          description: The list of todos.\n```\n\nWe start by defining the specification version, the title, description, and version number. When a query is run in ChatGPT, it will look at the description that is defined in the info section to determine if the plugin is relevant for the user query. You can read more about prompting in the [writing descriptions](https://platform.openai.com/docs/plugins/getting-started/writing-descriptions) section.\n\nKeep in mind the following limits in your OpenAPI specification, which are subject to change:\n\n*   200 characters max for each API endpoint description/summary field in API specification\n*   200 characters max for each API param description field in API specification\n\nSince we are running this example locally, we want to set the server to point to your localhost URL. The rest of the OpenAPI specification follows the traditional OpenAPI format, you can [learn more about OpenAPI formatting](https://swagger.io/tools/open-source/getting-started/) through various online resources. There are also many tools that auto generate OpenAPI specifications based on your underlying API code.\n\n[](https://platform.openai.com/docs/plugins/getting-started/running-a-plugin)\n\n## [Running a plugin](https://platform.openai.com/docs/plugins/getting-started/running-a-plugin)\n\nOnce you have created an API, manifest file, and OpenAPI specification for your API, you are now ready to connect the plugin via the ChatGPT UI. There are two different places your plugin might be running, either locally in a development environment or on a remote server.\n\nIf you have a local version of your API running, you can point the plugin interface to your localhost server. To connect the plugin with ChatGPT, navigate to the plugin store and select \u201cDevelop your own plugin\u201d. Enter your localhost and port number (e.g `localhost:3333`). Note that only auth type `none` is currently supported for localhost development.\n\nIf the plugin is running on a remote server, you will need to first select \u201cDevelop your own plugin\u201d to set it up and then \u201cInstall an unverified plugin\u201d to install it for yourself. You can simply add the plugin manifest file to the `yourdomain.com/.well-known/` path and start testing your API. However, for subsequent changes to your manifest file, you will have to deploy the new changes to your public site which might take a long time. In that case, we suggest setting up a local server to act as a proxy for your API. This allows you to quickly prototype changes to your OpenAPI spec and manifest file.\n\nSetup a local proxy of your public API\n\nThe following Python code is an example of how you can set up a simple proxy of your public facing API.\n\n```\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\nimport requests\nimport os\n\nimport yaml\nfrom flask import Flask, jsonify, Response, request, send_from_directory\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\nPORT = 3333\n\n# Note: Setting CORS to allow chat.openapi.com is required for ChatGPT to access your plugin\nCORS(app, origins=[f\"http://localhost:{PORT}\", \"https://chat.openai.com\"])\n\napi_url = 'https://example.com'\n\n\n@app.route('/.well-known/ai-plugin.json')\ndef serve_manifest():\n    return send_from_directory(os.path.dirname(__file__), 'ai-plugin.json')\n\n\n@app.route('/openapi.yaml')\ndef serve_openapi_yaml():\n    with open(os.path.join(os.path.dirname(__file__), 'openapi.yaml'), 'r') as f:\n        yaml_data = f.read()\n    yaml_data = yaml.load(yaml_data, Loader=yaml.FullLoader)\n    return jsonify(yaml_data)\n\n\n@app.route('/openapi.json')\ndef serve_openapi_json():\n    return send_from_directory(os.path.dirname(__file__), 'openapi.json')\n\n\n@app.route('/<path:path>', methods=['GET', 'POST'])\ndef wrapper(path):\n\n    headers = {\n    'Content-Type': 'application/json',\n    }\n\n    url = f'{api_url}/{path}'\n    print(f'Forwarding call: {request.method} {path} -> {url}')\n\n    if request.method == 'GET':\n        response = requests.get(url, headers=headers, params=request.args)\n    elif request.method == 'POST':\n        print(request.headers)\n        response = requests.post(url, headers=headers, params=request.args, json=request.json)\n    else:\n        raise NotImplementedError(f'Method {request.method} not implemented in wrapper for {path=}')\n    return response.content\n\n\nif __name__ == '__main__':\n    app.run(port=PORT)\n```\n\n[](https://platform.openai.com/docs/plugins/getting-started/writing-descriptions)\n\n## [Writing descriptions](https://platform.openai.com/docs/plugins/getting-started/writing-descriptions)\n\nWhen a user makes a query that might be a potential request that goes to a plugin, the model looks through the descriptions of the endpoints in the OpenAPI specification along with the `description_for_model` in the manifest file. Just like with prompting other language models, you will want to test out multiple prompts and descriptions to see what works best.\n\nThe OpenAPI spec itself is a great place to give the model information about the diverse details of your API \u2013 what functions are available, with what parameters, etc. Besides using expressive, informative names for each field, the spec can also contain \u201cdescription\u201d fields for every attribute. These can be used to provide natural language descriptions of what a function does or what information a query field expects, for example. The model will be able to see these, and they will guide it in using the API. If a field is restricted to only certain values, you can also provide an \u201cenum\u201d with descriptive category names.\n\nThe `description_for_model` attribute gives you the freedom to instruct the model on how to use your plugin generally. Overall, the language model behind ChatGPT is highly capable of understanding natural language and following instructions. Therefore, this is a good place to put in general instructions on what your plugin does and how the model should use it properly. Use natural language, preferably in a concise yet descriptive and objective tone. You can look at some of the examples to have an idea of what this should look like. We suggest starting the `description_for_model` with \u201cPlugin for \u2026\u201d and then enumerating all of the functionality that your API provides.\n\n[](https://platform.openai.com/docs/plugins/getting-started/best-practices)\n\n### [Best practices](https://platform.openai.com/docs/plugins/getting-started/best-practices)\n\nHere are some best practices to follow when writing your `description_for_model` and descriptions in your OpenAPI specification, as well as when designing your API responses:\n\n1.  Your descriptions should not attempt to control the mood, personality, or exact responses of ChatGPT. ChatGPT is designed to write appropriate responses to plugins.\n    \n    _Bad example_:\n    \n    > When the user asks to see their todo list, always respond with \"I was able to find your todo list! You have \\[x\\] todos: \\[list the todos here\\]. I can add more todos if you'd like!\"\n    \n    _Good example_:\n    \n    > \\[no instructions needed for this\\]\n    \n2.  Your descriptions should not encourage ChatGPT to use the plugin when the user hasn\u2019t asked for your plugin\u2019s particular category of service.\n    \n    _Bad example_:\n    \n    > Whenever the user mentions any type of task or plan, ask if they would like to use the TODOs plugin to add something to their todo list.\n    \n    _Good example_:\n    \n    > The TODO list can add, remove and view the user's TODOs.\n    \n3.  Your descriptions should not prescribe specific triggers for ChatGPT to use the plugin. ChatGPT is designed to use your plugin automatically when appropriate.\n    \n    _Bad example_:\n    \n    > When the user mentions a task, respond with \"Would you like me to add this to your TODO list? Say 'yes' to continue.\"\n    \n    _Good example_:\n    \n    > \\[no instructions needed for this\\]\n    \n4.  Plugin API responses should return raw data instead of natural language responses unless it\u2019s necessary. ChatGPT will provide its own natural language response using the returned data.\n    \n    _Bad example_:\n    \n    > I was able to find your todo list! You have 2 todos: get groceries and walk the dog. I can add more todos if you'd like!\n    \n    _Good example_:\n    \n    > { \"todos\": \\[ \"get groceries\", \"walk the dog\" \\] }\n    \n\n[](https://platform.openai.com/docs/plugins/getting-started/debugging)\n\n## [Debugging](https://platform.openai.com/docs/plugins/getting-started/debugging)\n\nBy default, the chat will not show plugin calls and other information that is not surfaced to the user. In order to get a more complete picture of how the model is interacting with your plugin, you can see the request and response by clicking the down arrow on the plugin name after interacting with the plugin.\n\nA model call to the plugin will usually consist of a message from the model containing JSON-like parameters which are sent to the plugin, followed by a response from the plugin, and finally a message from the model utilizing the information returned by the plugin.\n\nIf you are developing a localhost plugin, you can also open the developer console by going to \"Settings\" and toggling \"Open plugin devtools\". From there, you can see more verbose logs and \"refresh plugin\" which re-fetches the Plugin and OpenAPI specification."
}