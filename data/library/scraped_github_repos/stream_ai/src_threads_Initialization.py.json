{
    "metadata": {
        "type": "repo",
        "path": "src/threads/Initialization.py"
    },
    "text": "'''\n    Initialization.py contains the Initialization class, which is responsible for initializing the system.\n    \n    Initializes and synchronizes predictions with video using YOLO and signals.\n'''\nimport src.variables.global_vars as GV\nimport src.helpers.helper_functions as helpers\nimport src.helpers.inference as inference\nimport src.helpers.gcode_functions as g\nimport src.variables.constants as c\nimport time\nimport gc\n\nclass Initialization:\n    def __init__(self, gcode_path):\n        self.initialization_video_buffer = []\n        self.gcode_path = gcode_path\n\n    def start(self):\n        self.initialize_ratio()\n\n    def initialize_ratio(self):\n        helpers.print_text('Initialization & Synchronization started', 'blue')\n        GV.bed_predictions, GV.angles, GV.corner_indices = g.gcode_parser(self.gcode_path, c.ACCELERATION, 30, c.TIME_K)\n        leftmost_x = 9999999\n        leftmost_x_signal_index = 0\n        leftmost_img = None\n        rightmost_x = -9999999\n        rightmost_x_signal_index = 0\n        rightmost_img = None\n        banned_signals = []\n        banned_signal_frames = []\n        first_signal_index = 0\n        second_signal_index = 0\n        while True:\n            # Loop until we find two signals far enough apart in the x direction\n            break_here = False\n            while True:\n                for signal_frame in GV.initialization_frame_signal_buffer:\n                    if signal_frame[0] in banned_signal_frames: continue\n                    this_signal = GV.signals[signal_frame[1]][2]\n                    this_frame = signal_frame[2]\n                    x = this_signal[0]\n                    if x < leftmost_x: \n                        leftmost_x = x\n                        leftmost_x_frame = signal_frame[0]\n                        leftmost_x_signal_index = signal_frame[1]\n                        leftmost_img = this_frame\n                        first_signal_index = second_signal_index\n                        second_signal_index = leftmost_x_signal_index\n                    if x > rightmost_x:\n                        rightmost_x = x\n                        rightmost_x_frame = signal_frame[0]\n                        rightmost_x_signal_index = signal_frame[1]\n                        rightmost_img = this_frame\n                        first_signal_index = second_signal_index\n                        second_signal_index = rightmost_x_signal_index\n                    if abs(rightmost_x - leftmost_x) > c.RATIO_INITIALIZATION_MIN_RANGE:\n                        break_here = True\n                if break_here: break\n                time.sleep(0.1)\n\n            # Get the bounding boxes of the two signals\n            leftmost_box = inference.infer_large_image(leftmost_img, GV.yolo_model, 550)\n            rightmost_box = inference.infer_large_image(rightmost_img, GV.yolo_model, 550)\n            \n            # If tip cannot be detected, find new signals\n            if leftmost_box[0] == -1:\n                leftmost_x = rightmost_x\n                banned_signal_frames.append(leftmost_x_frame)\n                continue\n            if rightmost_box[0] == -1:\n                rightmost_x = leftmost_x\n                banned_signal_frames.append(rightmost_x_frame)\n                continue\n            \n            # If the two signals are too far apart in the y direction, find new signals\n            if leftmost_box[1] - rightmost_box[1] > c.ACCEPTABLE_Y_DIFFERENCE:\n                rightmost_x = -9999999\n                leftmost_x = 9999999\n                banned_signals.append(leftmost_x_signal_index)\n                banned_signals.append(rightmost_x_signal_index)\n                continue\n            \n            break\n\n        if leftmost_x_frame > rightmost_x_frame: \n            GV.yolo_history.append([rightmost_x_frame, helpers.get_center_of_box(rightmost_box)])\n            GV.yolo_history.append([leftmost_x_frame, helpers.get_center_of_box(leftmost_box)])\n        else: \n            GV.yolo_history.append([leftmost_x_frame, helpers.get_center_of_box(leftmost_box)])\n            GV.yolo_history.append([rightmost_x_frame, helpers.get_center_of_box(rightmost_box)])\n\n        GV.current_y = GV.yolo_history[0][1][1]\n        # Calculate the ratio\n        pixel_difference = abs(leftmost_box[0] - rightmost_box[0])\n        millimeter_difference = rightmost_x - leftmost_x\n\n        GV.ratio = pixel_difference / millimeter_difference\n        del GV.initialization_video_buffer\n        del GV.initialization_frame_signal_buffer\n        gc.collect()\n        self.initialize_screen_predictions(first_signal_index)\n\n    def initialize_screen_predictions(self, first_signal_index):\n        first_yolo = GV.yolo_history[0]\n        first_yolo_frame_index = first_yolo[0]\n        first_signals_frame_index = GV.corner_indices[first_signal_index]\n        \n        # Align predictions with first signal\n        predictions_reindex = first_yolo_frame_index - first_signals_frame_index - 1 \n        GV.bed_predictions = helpers.modify_list(GV.bed_predictions, predictions_reindex)\n        GV.angles = helpers.modify_list(GV.angles, predictions_reindex)\n        GV.corner_indices = [corner_index + predictions_reindex for corner_index in GV.corner_indices]\n        \n        # Fill the screen_predictions list with [-1, -1] for all frames before first yolo\n        GV.screen_predictions = []\n        for i in range(first_yolo_frame_index):\n            GV.screen_predictions.append([-1, -1])\n        \n        tip = first_yolo[1].copy()\n        GV.screen_predictions.append(tip.copy())\n        for i in range(first_yolo_frame_index, len(GV.bed_predictions)):\n            x_millimeter_change = GV.bed_predictions[i-1][0] - GV.bed_predictions[i][0]\n            z_millimeter_change = GV.bed_predictions[i-1][2] - GV.bed_predictions[i][2]\n            \n            tip[0] -= x_millimeter_change * GV.ratio\n            tip[1] += z_millimeter_change * GV.ratio\n            \n            GV.screen_predictions.append([round(num) for num in tip.copy()])\n\n        GV.tracking = True\n        # Clear and free memory of frames (Was holding frames to be looked back at for this method)\n        helpers.print_text('Initialization & Synchronization Done', 'green')"
}