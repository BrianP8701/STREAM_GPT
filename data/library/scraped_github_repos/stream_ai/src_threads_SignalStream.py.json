{
    "metadata": {
        "type": "repo",
        "path": "src/threads/SignalStream.py"
    },
    "text": "'''\n    SignalStream is responsible for handling signals.\n    \n    Upon calling start(), SignalStream simulates the signal stream.\n    The signal_router() routes the signals to the appropriate places as they stream in.\n    The YOLO_thread() runs YOLO on corresponding frames when signals arrives and shares results with the spatial thread in ErrorCorrection.\n'''\nimport time\nimport threading\nimport src.helpers.helper_functions as helpers\nimport src.variables.global_vars as GV\nimport src.helpers.inference as inference\n\nclass SignalStream:\n    def __init__(self, signals_path, error_correction):\n        self.signals_path = signals_path\n        self.error_correction = error_correction\n        self.signals_not_saved_to_initialization_buffer = [] # [[signal_index, time [x,y,z]]... ]\n\n    def start(self):\n        self._simulate_signal_stream()\n\n    def _simulate_signal_stream(self):\n        helpers.print_text('Signal stream started', 'blue')\n        signal_list = helpers.parse_file(self.signals_path)\n        GV.video_start_event.wait()\n        threading.Thread(target=self._clear_initialization_video_buffer, args=()).start()        \n    \n        for signal in signal_list:\n            self._ensure_correct_signal_speed(signal)\n            self._signal_router(signal, GV.global_signal_index)  \n            GV.signals.append([GV.global_signal_index, signal[0], signal[1]])   \n            GV.global_signal_index += 1\n        \n        helpers.print_text('Signal stream ended', 'red')\n\n    def _signal_router(self, signal, signal_index):\n        signal_frame = helpers.millis_to_frames(signal[0], 30)\n        if GV.tracking:\n            threading.Thread(target=self.error_correction.temporal_thread, args=(signal_frame, signal_index,), daemon=True).start()\n            threading.Thread(target=self.YOLO_thread, args=(signal_frame,), daemon=True).start()\n        else:\n            self._add_frame_to_initialization_buffer(signal, signal_index)\n\n    # Everytime a signal arrives, run YOLO on the corresponding frame\n    def YOLO_thread(self, signal_time_frame):\n        if len(GV.screen_predictions) <= signal_time_frame: return\n        # Make sure video buffer has the corresponding frame\n        while True:\n            buffer = GV.yolo_video_buffer.copy()\n            buffer_start = buffer[0][0]\n            buffer_end = buffer[-1][0]\n            if signal_time_frame < buffer_start:\n                helpers.print_text('Frame not found in buffer', 'blue')\n                print(f'Frame {buffer[0][0]} to {buffer[-1][0]}\\nSignal time frame: {signal_time_frame}\\n')\n                raise Exception('Frame not found in buffer')\n            if signal_time_frame > buffer_end:\n                time.sleep(0.05)\n            if signal_time_frame >= buffer_start and signal_time_frame < buffer_end:\n                break\n            \n        # Find corresponding frame in video buffer\n        for frame, image in buffer:\n            if frame == signal_time_frame: \n                img = image.copy()\n                break\n        \n        # Get real screen location\n        predicted_screen_location = GV.screen_predictions[signal_time_frame]\n        sub_img = helpers.crop_image_around_point(img, predicted_screen_location[0], predicted_screen_location[1], 640)\n        try:\n            real_screen_box = inference.yolo_inference(sub_img, GV.yolo_model)\n        except:\n            helpers.print_text(f\"{sub_img}\\n{predicted_screen_location}\\n{signal_time_frame}\\n{sub_img.shape}\\n{type(sub_img)}\\nYOLO failed\\n\", 'red')\n            print(f'Frame {buffer[0][0]} to {buffer[-1][0]}\\nSignal time frame: {signal_time_frame}\\n')\n        subimg_location = helpers.get_center_of_box(real_screen_box)\n        real_screen_location = [subimg_location[0] - 320 + predicted_screen_location[0], subimg_location[1] - 320 + predicted_screen_location[1]]\n        \n        # Call spatial thread is YOLO prediction appears valid\n        if not abs(real_screen_location[1] - GV.current_y) > 30: \n            threading.Thread(target=self.error_correction.spatial_thread, args=(signal_time_frame, real_screen_location,), daemon=True).start()\n            \n    def _ensure_correct_signal_speed(self, signal):\n        signal_time = signal[0] / 1000.0  # Convert milliseconds to seconds\n        time_to_wait = signal_time - (time.time() - GV.start_time)\n        if time_to_wait > 0:\n            time.sleep(time_to_wait)\n\n    # Add signals and corresponding images to initialization_frame_signal_buffer\n    def _add_frame_to_initialization_buffer(self, signal, signal_index):\n        self.signals_not_saved_to_initialization_buffer.append([signal_index, signal[0], signal[1]])\n        for signal_ in self.signals_not_saved_to_initialization_buffer[:]:\n            # Get index corresponding to signal_ in signals_not_saved_to_initialization_buffer\n            corresponding_video_index = round((signal_[1] / 1000.0) * 30)\n            try:\n                index_in_initialization_buffer = corresponding_video_index - GV.initialization_video_buffer[0][0]\n            except:\n                return\n            if len(GV.initialization_video_buffer) > index_in_initialization_buffer:\n                GV.initialization_frame_signal_buffer.append([corresponding_video_index, signal_[0], \n                                                                GV.initialization_video_buffer[index_in_initialization_buffer][1]])\n                # Delete all images from the initialization_video_buffer that are no longer needed.\n                del self.signals_not_saved_to_initialization_buffer[0]\n                del GV.initialization_video_buffer[0:index_in_initialization_buffer+1]\n            else: break\n    \n    # Clear initialization_video_buffer when there are no signals arriving\n    def _clear_initialization_video_buffer(self):\n        was_previous_length_zero = False\n        while True:\n            if GV.tracking:\n                break\n            else:\n                if was_previous_length_zero and len(self.signals_not_saved_to_initialization_buffer) == 0:\n                    try: GV.initialization_video_buffer.clear()\n                    except: pass\n                    was_previous_length_zero = False\n                    \n                if len(self.signals_not_saved_to_initialization_buffer) == 0:\n                    was_previous_length_zero = True\n                time.sleep(10)"
}