{
    "metadata": {
        "type": "repo",
        "path": "src/threads/ErrorCorrection.py"
    },
    "text": "# YOLOHandler.py\nimport src.variables.global_vars as GV\nimport src.helpers.helper_functions as helpers\nimport src.variables.constants as c\n\nclass ErrorCorrection:\n    def __init__(self):\n        pass\n    \n    def temporal_thread(self, frame, signal_index):\n        if signal_index < len(GV.corner_indices): \n            predicted_time_frame = GV.corner_indices[signal_index]\n        else: return\n         \n        screen_temporal_offset = frame - predicted_time_frame\n        GV.screen_predictions, GV.bed_predictions, GV.angles, GV.corner_indices = helpers.time_travel(GV.screen_predictions, GV.bed_predictions, GV.angles, GV.corner_indices, frame, screen_temporal_offset)\n\n    def spatial_thread(self, frame, real_screen_tip):\n        spatial_offset = [real_screen_tip[0] - GV.screen_predictions[frame][0], real_screen_tip[1] - GV.screen_predictions[frame][1]]\n        GV.x_spatial_offsets.append([frame, spatial_offset[0]])\n        GV.y_spatial_offsets.append([frame, spatial_offset[1]])\n        \n        if len(GV.x_spatial_offsets) > c.X_SPATIAL_MIN_SIGNALS: GV.x_spatial_offsets.pop(0)\n        if len(GV.y_spatial_offsets) > c.Y_SPATIAL_MIN_SIGNALS: GV.y_spatial_offsets.pop(0)\n        \n        # x spatial offsets\n        if len(GV.x_spatial_offsets) == c.X_SPATIAL_MIN_SIGNALS: # If we have enough signals\n            if max(GV.x_spatial_offsets, key=lambda x: x[1])[1] - min(GV.x_spatial_offsets, key=lambda x: x[1])[1] < c.X_SPATIAL_MAX_DEVIATION: # If the spatial offsets are close enough together\n                average_spatial_offset = sum(pair[1] for pair in GV.x_spatial_offsets) / len(GV.x_spatial_offsets)\n                if abs(average_spatial_offset) > 2:\n                    helpers.print_text('Adjust X spatially', 'green')\n                    for screen_prediction in GV.screen_predictions[frame:]:\n                        screen_prediction[0] += average_spatial_offset  \n                    GV.x_spatial_offsets.clear()\n        \n        # y spatial offsets\n        if len(GV.y_spatial_offsets) == c.Y_SPATIAL_MIN_SIGNALS: # If we have enough signals\n            if max(GV.y_spatial_offsets, key=lambda x: x[1])[1] - min(GV.y_spatial_offsets, key=lambda x: x[1])[1] < c.Y_SPATIAL_MAX_DEVIATION: # If the spatial offsets are close enough together\n                average_spatial_offset = sum(pair[1] for pair in GV.y_spatial_offsets) / len(GV.y_spatial_offsets)\n                if abs(average_spatial_offset) > 10: # If the spatial offset is large enough to be significant\n                    helpers.print_text('Adjust Y spatially', 'green')\n                    for screen_prediction in GV.screen_predictions[frame:]:\n                        screen_prediction[1] += average_spatial_offset\n                    GV.current_y += average_spatial_offset\n                    GV.y_spatial_offsets.clear()       "
}