{
    "metadata": {
        "type": "repo",
        "path": "src/helpers/measure_diameter.py"
    },
    "text": "import numpy as np\nimport cv2\nimport math\nfrom matplotlib import pyplot as plt\n\ndef draw_line(img, slope, intercept):\n    def equation(x): return int(slope * x + intercept)\n    pt1 = equation(0)\n    pt2 = equation(len(img[0])-1)\n    return cv2.line(img, [0, pt1], [len(img[0])-1, pt2], (255, 0, 0), 1)\n\ndef rad_to_deg(degree):\n    return (degree * math.pi) / 180\n\ndef whiten(img: np.ndarray):\n    x = np.std(img)\n    rang = 2.04023 * x - 4.78237\n    if(x < 20): rang = 5\n    whitestPixel = 0\n    for i in range(len(img)):\n        for j in range(len(img[0])):\n            if(img[i][j] > whitestPixel): whitestPixel = img[i][j]\n    for i in range(len(img)):\n        for j in range(len(img[0])):\n            if(img[i][j] > whitestPixel - rang): img[i][j] = 255\n    cutoff = 255 - rang\n    while(True):    \n        whitestPixel = 0\n        for i in range(len(img)):\n            for j in range(len(img[0])):\n                if(img[i][j] < cutoff and img[i][j] > whitestPixel): whitestPixel = img[i][j]\n        if whitestPixel == 0: break\n        for i in range(len(img)):\n            for j in range(len(img[0])):\n                if(img[i][j] > whitestPixel - rang and img[i][j] < cutoff): img[i][j] = whitestPixel\n        cutoff = whitestPixel - rang\n    return img\n\ndef get_pixels_of_line(img, slope, intercept):\n    allPixels = []\n    Y = len(img)\n    X = len(img[0])\n    xstep = 1\n    if abs(slope) > 1:\n        xstep = 1 / abs(slope)\n    ystep = slope * xstep\n    x = 0\n    y = intercept\n    while(True):\n        if(y < 0 or x >= X): break\n        if(y < Y): allPixels.append([int(y), int(x)])\n        x = x + xstep\n        y = y + ystep\n    return allPixels\n\ndef diagonal(pixel, img): return img[pixel[0]-1][pixel[1]+1] - img[pixel[0]+1][pixel[1]-1] == 0\ndef horizontal(pixel, img): return img[pixel[0]-1][pixel[1]] - img[pixel[0]+1][pixel[1]] == 0\ndef vertical(pixel, img): return img[pixel[0]][pixel[1]-1] - img[pixel[0]][pixel[1]+1] == 0\n\ndef get_confidence(img, all_pixels, slope):\n    if abs(slope) < 0.7: \n        def func(pixel, img): return vertical(pixel, img)\n    elif abs(slope) < 1.428: \n        def func(pixel, img): return diagonal(pixel, img)\n    else:\n        def func(pixel, img): return horizontal(pixel, img)\n    confidence = 0\n    for pixel in all_pixels:\n        if(pixel[0] == 0 or pixel[0] == len(img)-1 or pixel[1] == 0 or pixel[1] == len(img[0])-1): continue\n        if(not func(pixel, img)): confidence = confidence + 1\n    return confidence\n\ndef get_center(img):\n    return np.array([int(len(img[0]) / 2), int(len(img) / 2)])\n\ndef distance_from_point_to_line(slope, intercept, point):\n    x = point[0]\n    y = point[1]\n    distance = abs((slope * x) - y + intercept) / math.sqrt(1 + (slope ** 2))\n    return distance\n\ndef line_to_line(slope, intercept1, intercept2):\n    return abs(intercept2 - intercept1) / math.sqrt((slope * slope) + 1)\n\ndef draw_rectangle(image, tip):\n    cv2.rectangle(image, (tip[0][0]-2, tip[0][1]-2), (tip[0][0]+3, tip[0][1]+3), (255, 0, 0), 1)\n    cv2.rectangle(image, (tip[1][0]-2, tip[0][1]-2), (tip[1][0]+3, tip[0][1]+3), (255, 0, 0), 1)\n    cv2.imshow('', image)\n    cv2.waitKey(10000)\n\ndef tip_outline(mTp, img):\n    width = round(2.890 * mTp - 23.763)\n    height = round(width * 2.5)\n    \n    kingOfTheHill = [0,0]\n    highestConfidence = 0\n    for x in range(0, len(img[0])-width-10):\n        for y in range(0, len(img)-height-8):\n            matrix = img[y:y+height+6, x:x+width+8]\n            confidence = 0\n            confidenceMultiple = 2.5\n            # Vertical\n            for i in range(0, 2):\n                confidenceMultiple += 1\n                for j in range(0, height):\n                    if(matrix[j][0 + i] != matrix[j][8 - i]): confidence += confidenceMultiple\n                    if(matrix[j][width-4+i] != matrix[j][width+4-i]): confidence += confidenceMultiple\n                    \n            confidenceMultiples = [6, 4, 4, 4, 2]\n            # Horizontal\n            for i in range(0, 5): \n                confidenceMultiple = confidenceMultiples[i]\n                for j in range(4, width-4):\n                    if(matrix[height-1-i][j] != matrix[height-12+i][j]): confidence += confidenceMultiple\n            if(confidence > highestConfidence): \n                kingOfTheHill = [[x+5, y+height],[x+width+3, y+height]]\n                highestConfidence = confidence\n    return kingOfTheHill\n\ndef measure_diameter(img, theta, tip):\n    if(theta >= 90):\n        img = np.flip(img, 1)\n        theta = 180 - theta\n    slope = -math.tan(rad_to_deg(theta)) \n    slope_adjustment = 0.05 * slope # Trying slightly different slopes than given\n    slope = slope - slope_adjustment\n    highestConfidence = [0,0]\n    pair = [[],[]] # slope, y intercept\n    jump = -slope            # How much we change intercept by for each iteration\n    if(jump < 1): jump = 1\n    center = get_center(img)\n    for q in range(0, 3):\n        tip_intercept = tip[1] - slope * tip[0]\n        intercept = 10\n        highestconf = [0,0]\n        curr_pair = [[],[]]\n        last_line_intercept = -1000\n        while(True):\n            # IF line too close, only add if high conf. Otherwise continue to next\n            this_lines_pixels = get_pixels_of_line(img, slope, intercept)\n            if(len(this_lines_pixels) == 0): break \n            confidence = get_confidence(img, this_lines_pixels, slope)\n            tip_multiple = distance_from_point_to_line(slope, intercept, tip)\n            tip_multiple = -0.009*tip_multiple**2+0.084*tip_multiple+9.846\n            if(tip_multiple < 1): tip_multiple = 1\n            confidence *= tip_multiple\n            if(line_to_line(slope, intercept, last_line_intercept) > 4):\n                if(confidence > highestconf[0]):\n                    highestconf[1] = highestconf[0]\n                    curr_pair[1] = curr_pair[0]\n                    highestconf[0] = confidence\n                    curr_pair[0] = [slope, intercept]\n                    last_line_intercept = intercept\n                elif(confidence > highestconf[1]):\n                    highestconf[1] = confidence\n                    curr_pair[1] = [slope, intercept]\n                    last_line_intercept = intercept\n            intercept = intercept + jump\n        slope = slope + slope_adjustment\n        if(sum(highestconf) / 2 > sum(highestConfidence) / 2): \n            highestConfidence = highestconf\n            pair = curr_pair\n    return pair\n\nimage_path = '/Users/brianprzezdziecki/Research/Mechatronics/STREAM_AI/data/edgeimg/Edge7.jpeg'\nimage = cv2.imread(image_path)[:,:,0]\nwhiten(image)\n\npair = measure_diameter(image, 45, [53,45])\n#image = np.flip(image, 1)\nslope = pair[0][0]\nintercept = pair[0][1]\nallpixels = get_pixels_of_line(image, slope, intercept)\nfor pixel in allpixels:\n    image[pixel[0]][pixel[1]] = 0\n\nslope = pair[1][0]\nintercept = pair[1][1]\nallpixels = get_pixels_of_line(image, slope, intercept)\nfor pixel in allpixels:\n    image[pixel[0]][pixel[1]] = 0\n\nimage = np.dstack([image, image, image])\nplt.imshow(image, interpolation='nearest')\nplt.show()\n#image = draw_line(image, slope, intercept)\n\n\n\n# python -c \"import torch; model = torch.load('/Users/brianprzezdziecki/Downloads/yolov8s.pt'); torch.onnx.export(model, torch.randn(1, 3, 224, 224), 'model.onnx', input_names=['input'], output_names=['output'])\"\n"
}