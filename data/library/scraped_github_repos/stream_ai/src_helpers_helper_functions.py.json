{
    "metadata": {
        "type": "repo",
        "path": "src/helpers/helper_functions.py"
    },
    "text": "'''\nThis file contains helper functions that are used in multiple places.\n'''\nimport numpy as np\nimport cv2\nimport sys\nimport os\nimport json\nimport math\n\ndef parse_file(filename):\n    ''' \n    Parse a file with the format:\n        2023-06-26 11:26:09\n        Nozzle position X\tNozzle position Y\tNozzle position Z\t\n        4904\t0.00\t0.00\t5.00\t\n        5518\t5.00\t0.00\t5.00\t\n        6590\t0.00\t5.00\t5.00\t\n        9193\t0.00\t0.00\t2.00\t\n        ...\n\n    Returns a list of lists of the format:\n        [[time, [x, y, z]], ...]\n    '''\n    with open(filename, 'r') as file:\n        lines = file.readlines()[8:]  # Skip the first eight lines\n\n    data = []\n    for line in lines:\n        parts = line.split()  # Split the line into parts\n        time = int(parts[0])  # The first part is the time\n        x = float(parts[1])  # The second part is the x-coordinate\n        y = float(parts[2])  # The third part is the y-coordinate\n        z = float(parts[3])  # The fourth part is the z-coordinate\n        data.append([time, [x, y, z]])\n\n    return data\n\n\ndef crop_image_around_point(img, x, y, size):\n    if isinstance(img, str):\n        img = cv2.imread(img)\n\n    # Calculate the coordinates of the crop\n    left = int(x - size // 2)\n    top = int(y - size // 2)\n    right = int(x + size // 2)\n    bottom = int(y + size // 2)\n\n    # Crop the image using numpy slicing\n    img_cropped = img[top:bottom, left:right]\n\n    return img_cropped\n\n# Given a video and frame, return that frame as a numpy array\ndef get_frame(video_path, frame_number):\n    \n    # Open the video file\n    video = cv2.VideoCapture(video_path)\n\n    # Set the current frame position\n    video.set(cv2.CAP_PROP_POS_FRAMES, frame_number)\n\n    # Read the frame\n    ret, frame = video.read()\n\n    # If the frame was read successfully, return it\n    if ret:\n        return frame\n    else:\n        return None\n\ndef get_center_of_box(box):\n    x1, y1, x2, y2 = box\n    center_x = int((x1 + x2) / 2)\n    center_y = int((y1 + y2) / 2)\n    return [center_x, center_y]\n\ndef get_bounding_box(center, size):\n    x, y = center\n    half_size = size / 2\n    top_left_x = round(x - half_size)\n    top_left_y = round(y - half_size)\n    return [top_left_x, top_left_y, top_left_x + size, top_left_y + size]\n\n\ndef get_queue_memory_usage(q):\n    temp_list = []\n    total_size = sys.getsizeof(q)\n\n    while not q.empty():\n        item = q.get()\n        total_size += sys.getsizeof(item)\n        temp_list.append(item)\n\n    for item in temp_list:\n        q.put(item)\n\n    return total_size\n\ndef print_text(text, text_color='white', bg_color='black'):\n    text_colors = {\n        'black': '30',\n        'red': '31',\n        'green': '32',\n        'yellow': '33',\n        'blue': '34',\n        'magenta': '35',\n        'cyan': '36',\n        'white': '37'\n    }\n    \n    bg_colors = {\n        'black': '40',\n        'red': '41',\n        'green': '42',\n        'yellow': '43',\n        'blue': '44',\n        'magenta': '45',\n        'cyan': '46',\n        'white': '47'\n    }\n    \n    print(f\"\\033[{text_colors[text_color]}m\\033[{bg_colors[bg_color]}m{text}\\033[0m\")\n        \ndef modify_list(lst, num):\n    if num > 0:\n        return [-1] * num + lst\n    elif num < 0:\n        return lst[abs(num):]\n    else:\n        return lst\n\ndef find_matching_index(bed_predictions, corner_indices, target_coords):\n    \"\"\"\n    Find the index (from corner_indices) of a coordinate in bed_predictions \n    that matches the given target coordinate within an acceptable difference.\n\n    Args:\n    - bed_predictions (list of list): List of 3D coordinates, e.g., [[x1, y1, z1], [x2, y2, z2], ...].\n    - corner_indices (list of int): List of indices referring to bed_predictions.\n    - target_coords (list): Target 3D coordinate to match, e.g., [x, y, z].\n\n    Returns:\n    - int: Index from corner_indices of the matching coordinate or None if no match found.\n    \"\"\"\n    \n    acceptable_difference = 0.01\n   \n    rounded_bed_predictions = []\n    for coord in bed_predictions:\n        rounded_coord = [int(x * 100) / 100.0 for x in coord]\n        rounded_bed_predictions.append(rounded_coord)\n        \n    for index in corner_indices:\n        coord = rounded_bed_predictions[index]\n        differences = [abs(coord[i] - target_coords[i]) for i in range(2)]\n        if all(diff <= acceptable_difference for diff in differences):\n            return index\n    return None\n\ndef millis_to_frames(millis, fps):\n    return round((millis / 1000) * fps)\n\n\ndef save_unique_image(folder_path, image_np):\n    \"\"\" Save the given image to the specified folder with a unique name. \"\"\"\n    if not os.path.exists(folder_path):\n        os.makedirs(folder_path)\n    \n    # Find a unique filename\n    index = 0\n    while True:\n        filename = f\"frame{index}.jpg\"\n        full_path = os.path.join(folder_path, filename)\n        \n        if not os.path.exists(full_path):\n            break\n        index += 1\n    \n    # Save the image\n    cv2.imwrite(full_path, image_np)\n\ndef save_list_to_json(data_list, destination_path):\n    # Ensure the provided data is a list\n    if not isinstance(data_list, list):\n        raise ValueError(\"Provided data is not a list\")\n\n    # Create directories if they don't exist\n    directory = os.path.dirname(destination_path)\n    if directory and not os.path.exists(directory):\n        os.makedirs(directory)\n\n    # Save the list to the JSON file\n    with open(destination_path, 'w') as json_file:\n        json.dump(data_list, json_file)\n\n\ndef resize_image(image, scale_percent):\n    \"\"\"\n    Resize the image by the given scale percentage.\n    \n    :param image: Input image.\n    :param scale_percent: Percentage by which the image should be scaled. E.g., 50 means the image will be half its original size.\n    :return: Resized image.\n    \"\"\"\n    width = int(image.shape[1] * scale_percent / 100)\n    height = int(image.shape[0] * scale_percent / 100)\n    dim = (width, height)\n    resized = cv2.resize(image, dim, interpolation=cv2.INTER_AREA)\n    return resized\n\ndef read_image(img_path):\n    img = cv2.imread(img_path)\n    return img\n\ndef show_image(img):\n    cv2.imshow('image', img)\n    cv2.waitKey(0)\n    \ndef save_image(img, img_path):\n    # Save the image\n    cv2.imwrite(img_path, img)\n\ndef magnitude(vector):\n    return np.linalg.norm(vector)\n\ndef normalize(vector):\n    return vector / np.linalg.norm(vector)\n\ndef add_empty_frames_to_video(video_path, destination_path, delay_frames):\n    # Open the video\n    cap = cv2.VideoCapture(video_path)\n    if not cap.isOpened():\n        raise ValueError(\"Couldn't open the video file.\")\n\n    # Get video properties\n    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    fps = cap.get(cv2.CAP_PROP_FPS)\n    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n\n    # Create a video writer object\n    out = cv2.VideoWriter(destination_path, fourcc, fps, (width, height))\n\n    # Create an empty (black) frame\n    empty_frame = np.zeros((height, width, 3), dtype=np.uint8)\n\n    # Add the empty frames to the beginning\n    for _ in range(delay_frames):\n        out.write(empty_frame)\n\n    frame_index = delay_frames\n    # Write the original video frames\n    while True:\n        ret, frame = cap.read()\n        print(frame_index)\n        frame_index += 1\n        if not ret:\n            break\n        out.write(frame)\n\n    # Release the video objects\n    cap.release()\n    out.release()\n    \ndef remove_frames(input_path, output_path, num_frames_to_remove):\n    \"\"\"\n    Removes a specified number of frames from the beginning of a video.\n    \n    Args:\n    - input_path (str): Path to the input video file.\n    - output_path (str): Path to save the output video file.\n    - num_frames_to_remove (int): Number of frames to remove from the beginning of the video.\n\n    Returns:\n    None\n    \"\"\"\n\n    # Open the video file\n    cap = cv2.VideoCapture(input_path)\n    if not cap.isOpened():\n        print(\"Error: Couldn't open the video file.\")\n        return\n\n    # Get video properties\n    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    fps = int(cap.get(cv2.CAP_PROP_FPS))\n    fourcc = cv2.VideoWriter_fourcc(*'mp4v')\n\n    # Create a VideoWriter object to save the video\n    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))\n\n    frame_count = 0\n    while True:\n        ret, frame = cap.read()\n\n        if not ret:\n            break  # Video file ended\n\n        frame_count += 1\n\n        # If we've skipped enough frames, write the current frame to the output\n        if frame_count > num_frames_to_remove:\n            out.write(frame)\n\n    # Release the VideoCapture and VideoWriter objects and close video file\n    cap.release()\n    out.release()\n    \n# Time travel. Every {interval} frames, either add or remove a frame based on the offset.\n# Positive - add frames\n# Negative - remove frames\ndef time_travel(screen_predictions, bed_predictions, angles, corner_indices,  current_frame_index, offset, interval=0):\n    adjusted_screen_predictions = screen_predictions.copy()\n    adjusted_bed_predictions = bed_predictions.copy()\n    adjusted_angles = angles.copy()\n    adjusted_corner_indices = corner_indices.copy()\n    if offset > 0:  # We're ahead and need to add buffer frames.\n        for i in range(offset):\n            idx_to_modify = current_frame_index + i*interval\n            if idx_to_modify < len(adjusted_screen_predictions):\n                adjusted_screen_predictions.insert(idx_to_modify, adjusted_screen_predictions[idx_to_modify])\n                adjusted_bed_predictions.insert(idx_to_modify, adjusted_bed_predictions[idx_to_modify])\n                adjusted_angles.insert(idx_to_modify, adjusted_angles[idx_to_modify])\n                first_signal_index = find_index(adjusted_corner_indices, idx_to_modify)\n                for i in range(first_signal_index, len(adjusted_corner_indices)):\n                    adjusted_corner_indices[i] += 1\n            else:\n                break  # Reached end of the list, can't add more\n\n    elif offset < 0:  # We're behind and need to remove frames.\n        for i in range(abs(offset)):\n            idx_to_modify = current_frame_index + i*interval\n            if idx_to_modify < len(adjusted_screen_predictions):\n                del adjusted_screen_predictions[idx_to_modify]\n                del adjusted_bed_predictions[idx_to_modify]\n                del adjusted_angles[idx_to_modify]\n                first_signal_index = find_index(adjusted_corner_indices, idx_to_modify)\n                for i in range(first_signal_index, len(adjusted_corner_indices)):\n                    adjusted_corner_indices[i] -= 1\n            else:\n                break  # Reached end of the list, can't remove more\n\n    return adjusted_screen_predictions, adjusted_bed_predictions, adjusted_angles, adjusted_corner_indices\n\n\ndef least_squares_slope_stddev(x, y):\n    '''\n    Given a list of x and y values, uses least squares to calculate the slope and standard deviation of the slope\n    '''\n    # Ensure the input arrays are NumPy arrays\n    x = np.array(x)\n    y = np.array(y)\n\n    # Calculate the means of x and y\n    x_mean = np.mean(x)\n    y_mean = np.mean(y)\n\n    # Calculate the slope (m) using the least squares method\n    slope = np.sum((x - x_mean) * (y - y_mean)) / np.sum((x - x_mean)**2)\n\n    # Calculate the standard deviation of the slope\n    n = len(x)\n    residuals = y - (slope * x)\n    stdev = np.sqrt(np.sum(residuals**2) / ((n - 2) * np.sum((x - x_mean)**2)))\n\n    return slope, stdev\n\n\ndef compute_slope_from_range(coords: list, range_val: float) -> float:\n    \"\"\"\n    Calculate the slope of the line segment defined by the most recent point and \n    the point which is 'range_val' units back in the x direction.\n    \n    Args:\n    - coords: List of [x, y] sublists representing coordinates, sorted in ascending order by x.\n    - range_val: Distance in the x direction to compute the slope.\n    \n    Returns:\n    - Slope of the line segment.\n    \"\"\"\n    \n    # Get the most recent point (last in the list)\n    x_recent, y_recent = coords[-1]\n    \n    # Find the point that is 'range_val' units back in x direction\n    x_target = x_recent - range_val\n    \n    # Find the closest x value to x_target in the list (assuming the coordinates are sorted)\n    target_coord = min(coords, key=lambda coord: abs(coord[0] - x_target))\n    \n    # Compute the slope\n    slope = (y_recent - target_coord[1]) / (x_recent - target_coord[0])\n    \n    return slope\n\n\ndef find_index(lst, x):\n    \"\"\"Return the index of the first number in lst that is >= x.\"\"\"\n    for index, value in enumerate(lst):\n        if value >= x:\n            return index\n    return None  # Return None if no such number exists in the list\n\ndef get_line(point, angle):\n    \"\"\"\n    Returns the second point of line in the form of, of length 50, starting at (x, y) and at the given angle.\n    \n    0 degrees is to te right, 90 degrees is up.\n    \"\"\"\n    angle_vector = [math.cos((angle*math.pi)/180)*50, math.sin((angle*math.pi)/180)*50] \n    angle_vector = [int(i) for i in angle_vector]\n    return [round(point[0]), round(point[1]), round(point[0]+angle_vector[0]), round(point[1]-angle_vector[1])]\n\n# Crops image in direction of angle. (For tracking the tip's extruded material)\ndef crop_in_direction(tip, line, angle):\n    vector = [line[2] - line[0], line[3] - line[1]]\n    center_of_new_box = [tip[0] - vector[0] * 0.8, tip[1] - vector[1] * 0.8]\n    if 0 <= angle <= 30 or 150 <= angle <= 180:\n        center_of_new_box = [center_of_new_box[0], center_of_new_box[1]+10]\n    elif 70 <= angle <= 110:\n        center_of_new_box = [center_of_new_box[0], center_of_new_box[1]-20]\n    box = get_bounding_box(center_of_new_box, 85)\n    return box\n\n# Makes some slight adjustments to calculated angle to account for parralax\ndef angle_adjustment(theta: float) -> float:\n    angle = ((theta + 180) % 360)\n    #if 0 < angle < 180:\n        #angle = angle**2 * 0.00123457 + 0.7777777 * angle\n    #if angle == 270:\n        #angle = 265\n    return angle\n\ndef crop_box_on_image(box, image):\n    \"\"\"\n    Given a box represented as [x1, y1, x2, y2] and an image, returns the subsection of the image.\n\n    Args:\n    - box (list of int): [x1, y1, x2, y2] defining the top-left and bottom-right corners of the box.\n    - image (numpy array): The image from which the subsection should be extracted.\n\n    Returns:\n    - numpy array: The extracted subsection of the image.\n    \"\"\"\n    \n    x1, y1, x2, y2 = box\n    \n    if len(image.shape) == 3:\n        # For a color image\n        return image[y1:y2, x1:x2, :]\n    else:\n        # For grayscale\n        return image[y1:y2, x1:x2]\n    "
}