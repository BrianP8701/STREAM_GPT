{
    "metadata": {
        "type": "web",
        "url": "https://docs.llamaindex.ai/en/stable/end_to_end_tutorials/apps/fullstack_app_guide.html",
        "title": "A Guide to Building a Full-Stack Web App with LLamaIndex - LlamaIndex \ud83e\udd99 0.8.49",
        "description": null
    },
    "text": "Toggle table of contents sidebar\n\nLlamaIndex is a python library, which means that integrating it with a full-stack web application will be a little different than what you might be used to.\n\nThis guide seeks to walk through the steps needed to create a basic API service written in python, and how this interacts with a TypeScript+React frontend.\n\nAll code examples here are available from the [llama\\_index\\_starter\\_pack](https://github.com/logan-markewich/llama_index_starter_pack/tree/main/flask_react) in the flask\\_react folder.\n\nThe main technologies used in this guide are as follows:\n\n*   python3.11\n    \n*   llama\\_index\n    \n*   flask\n    \n*   typescript\n    \n*   react\n    \n\n## Flask Backend[\uf0c1](#flask-backend \"Permalink to this heading\")\n\nFor this guide, our backend will use a [Flask](https://flask.palletsprojects.com/en/2.2.x/) API server to communicate with our frontend code. If you prefer, you can also easily translate this to a [FastAPI](https://fastapi.tiangolo.com/) server, or any other python server library of your choice.\n\nSetting up a server using Flask is easy. You import the package, create the app object, and then create your endpoints. Let\u2019s create a basic skeleton for the server first:\n\nfrom flask import Flask\n\napp \\= Flask(\\_\\_name\\_\\_)\n\n@app.route(\"/\")\ndef home():\n    return \"Hello World!\"\n\nif \\_\\_name\\_\\_ \\== \"\\_\\_main\\_\\_\":\n    app.run(host\\=\"0.0.0.0\", port\\=5601)\n\n_flask\\_demo.py_\n\nIf you run this file (`python flask_demo.py`), it will launch a server on port 5601. If you visit `http://localhost:5601/`, you will see the \u201cHello World!\u201d text rendered in your browser. Nice!\n\nThe next step is deciding what functions we want to include in our server, and to start using LlamaIndex.\n\nTo keep things simple, the most basic operation we can provide is querying an existing index. Using the [paul graham essay](https://github.com/jerryjliu/llama_index/blob/main/examples/paul_graham_essay/data/paul_graham_essay.txt) from LlamaIndex, create a documents folder and download+place the essay text file inside of it.\n\n### Basic Flask - Handling User Index Queries[\uf0c1](#basic-flask-handling-user-index-queries \"Permalink to this heading\")\n\nNow, let\u2019s write some code to initialize our index:\n\nimport os\nfrom llama\\_index import SimpleDirectoryReader, VectorStoreIndex, StorageContext\n\n\\# NOTE: for local testing only, do NOT deploy with your key hardcoded\nos.environ\\['OPENAI\\_API\\_KEY'\\] \\= \"your key here\"\n\nindex \\= None\n\ndef initialize\\_index():\n    global index\n    storage\\_context \\= StorageContext.from\\_defaults()\n    if os.path.exists(index\\_dir):\n        index \\= load\\_index\\_from\\_storage(storage\\_context)\n    else:\n        documents \\= SimpleDirectoryReader(\"./documents\").load\\_data()\n        index \\= VectorStoreIndex.from\\_documents(documents, storage\\_context\\=storage\\_context)\n        storage\\_context.persist(index\\_dir)\n\nThis function will initialize our index. If we call this just before starting the flask server in the `main` function, then our index will be ready for user queries!\n\nOur query endpoint will accept `GET` requests with the query text as a parameter. Here\u2019s what the full endpoint function will look like:\n\nfrom flask import request\n\n@app.route(\"/query\", methods\\=\\[\"GET\"\\])\ndef query\\_index():\n  global index\n  query\\_text \\= request.args.get(\"text\", None)\n  if query\\_text is None:\n    return \"No text found, please include a ?text=blah parameter in the URL\", 400\n  query\\_engine \\= index.as\\_query\\_engine()\n  response \\= query\\_engine.query(query\\_text)\n  return str(response), 200\n\nNow, we\u2019ve introduced a few new concepts to our server:\n\n*   a new `/query` endpoint, defined by the function decorator\n    \n*   a new import from flask, `request`, which is used to get parameters from the request\n    \n*   if the `text` parameter is missing, then we return an error message and an appropriate HTML response code\n    \n*   otherwise, we query the index, and return the response as a string\n    \n\nA full query example that you can test in your browser might look something like this: `http://localhost:5601/query?text=what did the author do growing up` (once you press enter, the browser will convert the spaces into \u201c%20\u201d characters).\n\nThings are looking pretty good! We now have a functional API. Using your own documents, you can easily provide an interface for any application to call the flask API and get answers to queries.\n\n### Advanced Flask - Handling User Document Uploads[\uf0c1](#advanced-flask-handling-user-document-uploads \"Permalink to this heading\")\n\nThings are looking pretty cool, but how can we take this a step further? What if we want to allow users to build their own indexes by uploading their own documents? Have no fear, Flask can handle it all :muscle:.\n\nTo let users upload documents, we have to take some extra precautions. Instead of querying an existing index, the index will become **mutable**. If you have many users adding to the same index, we need to think about how to handle concurrency. Our Flask server is threaded, which means multiple users can ping the server with requests which will be handled at the same time.\n\nOne option might be to create an index for each user or group, and store and fetch things from S3. But for this example, we will assume there is one locally stored index that users are interacting with.\n\nTo handle concurrent uploads and ensure sequential inserts into the index, we can use the `BaseManager` python package to provide sequential access to the index using a separate server and locks. This sounds scary, but it\u2019s not so bad! We will just move all our index operations (initializing, querying, inserting) into the `BaseManager` \u201cindex\\_server\u201d, which will be called from our Flask server.\n\nHere\u2019s a basic example of what our `index_server.py` will look like after we\u2019ve moved our code:\n\nimport os\nfrom multiprocessing import Lock\nfrom multiprocessing.managers import BaseManager\nfrom llama\\_index import SimpleDirectoryReader, VectorStoreIndex, Document\n\n\\# NOTE: for local testing only, do NOT deploy with your key hardcoded\nos.environ\\['OPENAI\\_API\\_KEY'\\] \\= \"your key here\"\n\nindex \\= None\nlock \\= Lock()\n\ndef initialize\\_index():\n  global index\n\n  with lock:\n    \\# same as before ...\n  ...\n\ndef query\\_index(query\\_text):\n  global index\n  query\\_engine \\= index.as\\_query\\_engine()\n  response \\= query\\_engine.query(query\\_text)\n  return str(response)\n\nif \\_\\_name\\_\\_ \\== \"\\_\\_main\\_\\_\":\n    \\# init the global index\n    print(\"initializing index...\")\n    initialize\\_index()\n\n    \\# setup server\n    \\# NOTE: you might want to handle the password in a less hardcoded way\n    manager \\= BaseManager(('', 5602), b'password')\n    manager.register('query\\_index', query\\_index)\n    server \\= manager.get\\_server()\n\n    print(\"starting server...\")\n    server.serve\\_forever()\n\n_index\\_server.py_\n\nSo, we\u2019ve moved our functions, introduced the `Lock` object which ensures sequential access to the global index, registered our single function in the server, and started the server on port 5602 with the password `password`.\n\nThen, we can adjust our flask code as follows:\n\nfrom multiprocessing.managers import BaseManager\nfrom flask import Flask, request\n\n\\# initialize manager connection\n\\# NOTE: you might want to handle the password in a less hardcoded way\nmanager \\= BaseManager(('', 5602), b'password')\nmanager.register('query\\_index')\nmanager.connect()\n\n@app.route(\"/query\", methods\\=\\[\"GET\"\\])\ndef query\\_index():\n  global index\n  query\\_text \\= request.args.get(\"text\", None)\n  if query\\_text is None:\n    return \"No text found, please include a ?text=blah parameter in the URL\", 400\n  response \\= manager.query\\_index(query\\_text).\\_getvalue()\n  return str(response), 200\n\n@app.route(\"/\")\ndef home():\n    return \"Hello World!\"\n\nif \\_\\_name\\_\\_ \\== \"\\_\\_main\\_\\_\":\n    app.run(host\\=\"0.0.0.0\", port\\=5601)\n\n_flask\\_demo.py_\n\nThe two main changes are connecting to our existing `BaseManager` server and registering the functions, as well as calling the function through the manager in the `/query` endpoint.\n\nOne special thing to note is that `BaseManager` servers don\u2019t return objects quite as we expect. To resolve the return value into it\u2019s original object, we call the `_getvalue()` function.\n\nIf we allow users to upload their own documents, we should probably remove the Paul Graham essay from the documents folder, so let\u2019s do that first. Then, let\u2019s add an endpoint to upload files! First, let\u2019s define our Flask endpoint function:\n\n...\nmanager.register('insert\\_into\\_index')\n...\n\n@app.route(\"/uploadFile\", methods\\=\\[\"POST\"\\])\ndef upload\\_file():\n    global manager\n    if 'file' not in request.files:\n        return \"Please send a POST request with a file\", 400\n\n    filepath \\= None\n    try:\n        uploaded\\_file \\= request.files\\[\"file\"\\]\n        filename \\= secure\\_filename(uploaded\\_file.filename)\n        filepath \\= os.path.join('documents', os.path.basename(filename))\n        uploaded\\_file.save(filepath)\n\n        if request.form.get(\"filename\\_as\\_doc\\_id\", None) is not None:\n            manager.insert\\_into\\_index(filepath, doc\\_id\\=filename)\n        else:\n            manager.insert\\_into\\_index(filepath)\n    except Exception as e:\n        \\# cleanup temp file\n        if filepath is not None and os.path.exists(filepath):\n            os.remove(filepath)\n        return \"Error: {}\".format(str(e)), 500\n\n    \\# cleanup temp file\n    if filepath is not None and os.path.exists(filepath):\n        os.remove(filepath)\n\n    return \"File inserted!\", 200\n\nNot too bad! You will notice that we write the file to disk. We could skip this if we only accept basic file formats like `txt` files, but written to disk we can take advantage of LlamaIndex\u2019s `SimpleDirectoryReader` to take care of a bunch of more complex file formats. Optionally, we also use a second `POST` argument to either use the filename as a doc\\_id or let LlamaIndex generate one for us. This will make more sense once we implement the frontend.\n\nWith these more complicated requests, I also suggest using a tool like [Postman](https://www.postman.com/downloads/?utm_source=postman-home). Examples of using postman to test our endpoints are in the [repository for this project](https://github.com/logan-markewich/llama_index_starter_pack/tree/main/flask_react/postman_examples).\n\nLastly, you\u2019ll notice we added a new function to the manager. Let\u2019s implement that inside `index_server.py`:\n\ndef insert\\_into\\_index(doc\\_text, doc\\_id\\=None):\n    global index\n    document \\= SimpleDirectoryReader(input\\_files\\=\\[doc\\_text\\]).load\\_data()\\[0\\]\n    if doc\\_id is not None:\n        document.doc\\_id \\= doc\\_id\n\n    with lock:\n        index.insert(document)\n        index.storage\\_context.persist()\n\n...\nmanager.register('insert\\_into\\_index', insert\\_into\\_index)\n...\n\nEasy! If we launch both the `index_server.py` and then the `flask_demo.py` python files, we have a Flask API server that can handle multiple requests to insert documents into a vector index and respond to user queries!\n\nTo support some functionality in the frontend, I\u2019ve adjusted what some responses look like from the Flask API, as well as added some functionality to keep track of which documents are stored in the index (LlamaIndex doesn\u2019t currently support this in a user-friendly way, but we can augment it ourselves!). Lastly, I had to add CORS support to the server using the `Flask-cors` python package.\n\nCheck out the complete `flask_demo.py` and `index_server.py` scripts in the [repository](https://github.com/logan-markewich/llama_index_starter_pack/tree/main/flask_react) for the final minor changes, the`requirements.txt` file, and a sample `Dockerfile` to help with deployment.\n\n## React Frontend[\uf0c1](#react-frontend \"Permalink to this heading\")\n\nGenerally, React and Typescript are one of the most popular libraries and languages for writing webapps today. This guide will assume you are familiar with how these tools work, because otherwise this guide will triple in length :smile:.\n\nIn the [repository](https://github.com/logan-markewich/llama_index_starter_pack/tree/main/flask_react), the frontend code is organized inside of the `react_frontend` folder.\n\nThe most relevant part of the frontend will be the `src/apis` folder. This is where we make calls to the Flask server, supporting the following queries:\n\n*   `/query` \u2013 make a query to the existing index\n    \n*   `/uploadFile` \u2013 upload a file to the flask server for insertion into the index\n    \n*   `/getDocuments` \u2013 list the current document titles and a portion of their texts\n    \n\nUsing these three queries, we can build a robust frontend that allows users to upload and keep track of their files, query the index, and view the query response and information about which text nodes were used to form the response.\n\n### fetchDocuments.tsx[\uf0c1](#fetchdocuments-tsx \"Permalink to this heading\")\n\nThis file contains the function to, you guessed it, fetch the list of current documents in the index. The code is as follows:\n\nexport type Document \\= {\n  id: string;\n  text: string;\n};\n\nconst fetchDocuments \\= async (): Promise<Document\\[\\]\\> \\=> {\n  const response \\= await fetch(\"http://localhost:5601/getDocuments\", {\n    mode: \"cors\",\n  });\n\n  if (!response.ok) {\n    return \\[\\];\n  }\n\n  const documentList \\= (await response.json()) as Document\\[\\];\n  return documentList;\n};\n\nAs you can see, we make a query to the Flask server (here, it assumes running on localhost). Notice that we need to include the `mode: 'cors'` option, as we are making an external request.\n\nThen, we check if the response was ok, and if so, get the response json and return it. Here, the response json is a list of `Document` objects that are defined in the same file.\n\n### queryIndex.tsx[\uf0c1](#queryindex-tsx \"Permalink to this heading\")\n\nThis file sends the user query to the flask server, and gets the response back, as well as details about which nodes in our index provided the response.\n\nexport type ResponseSources \\= {\n  text: string;\n  doc\\_id: string;\n  start: number;\n  end: number;\n  similarity: number;\n};\n\nexport type QueryResponse \\= {\n  text: string;\n  sources: ResponseSources\\[\\];\n};\n\nconst queryIndex \\= async (query: string): Promise<QueryResponse\\> \\=> {\n  const queryURL \\= new URL(\"http://localhost:5601/query?text=1\");\n  queryURL.searchParams.append(\"text\", query);\n\n  const response \\= await fetch(queryURL, { mode: \"cors\" });\n  if (!response.ok) {\n    return { text: \"Error in query\", sources: \\[\\] };\n  }\n\n  const queryResponse \\= (await response.json()) as QueryResponse;\n\n  return queryResponse;\n};\n\nexport default queryIndex;\n\nThis is similar to the `fetchDocuments.tsx` file, with the main difference being we include the query text as a parameter in the URL. Then, we check if the response is ok and return it with the appropriate typescript type.\n\n### insertDocument.tsx[\uf0c1](#insertdocument-tsx \"Permalink to this heading\")\n\nProbably the most complex API call is uploading a document. The function here accepts a file object and constructs a `POST` request using `FormData`.\n\nThe actual response text is not used in the app but could be utilized to provide some user feedback on if the file failed to upload or not.\n\nconst insertDocument \\= async (file: File) \\=> {\n  const formData \\= new FormData();\n  formData.append(\"file\", file);\n  formData.append(\"filename\\_as\\_doc\\_id\", \"true\");\n\n  const response \\= await fetch(\"http://localhost:5601/uploadFile\", {\n    mode: \"cors\",\n    method: \"POST\",\n    body: formData,\n  });\n\n  const responseText \\= response.text();\n  return responseText;\n};\n\nexport default insertDocument;\n\n### All the Other Frontend Good-ness[\uf0c1](#all-the-other-frontend-good-ness \"Permalink to this heading\")\n\nAnd that pretty much wraps up the frontend portion! The rest of the react frontend code is some pretty basic react components, and my best attempt to make it look at least a little nice :smile:.\n\nI encourage to read the rest of the [codebase](https://github.com/logan-markewich/llama_index_starter_pack/tree/main/flask_react/react_frontend) and submit any PRs for improvements!\n\n## Conclusion[\uf0c1](#conclusion \"Permalink to this heading\")\n\nThis guide has covered a ton of information. We went from a basic \u201cHello World\u201d Flask server written in python, to a fully functioning LlamaIndex powered backend and how to connect that to a frontend application.\n\nAs you can see, we can easily augment and wrap the services provided by LlamaIndex (like the little external document tracker) to help provide a good user experience on the frontend.\n\nYou could take this and add many features (multi-index/user support, saving objects into S3, adding a Pinecone vector server, etc.). And when you build an app after reading this, be sure to share the final result in the Discord! Good Luck! :muscle:"
}